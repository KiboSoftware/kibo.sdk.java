/*
 * Kibo Content Service
 * OpenAPI Spec for Kibo Content Service
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.kibocommerce.sdk.content.models;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.kibocommerce.sdk.content.models.ContentActiveDateRange;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.time.OffsetDateTime;
import org.openapitools.jackson.nullable.JsonNullable;
import java.io.Serializable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.kibocommerce.sdk.common.JSON;

/**
 * Container for schema-enforced and schemaless data. A document is primarily used to store content (html, text,  numbers, dates, JSON, binary data) that is directly or indirectly used for the storefront website experience  and may be addressed via the Hypr theming engine language. A document belongs to a documentList and has an  underlying documentType.  The documentType describes any required and optional schema. Additionally, a binary  object may be stored on the document&#39;s content subresource and edge cached via the Mozu CDN.
 */
@ApiModel(description = "Container for schema-enforced and schemaless data. A document is primarily used to store content (html, text,  numbers, dates, JSON, binary data) that is directly or indirectly used for the storefront website experience  and may be addressed via the Hypr theming engine language. A document belongs to a documentList and has an  underlying documentType.  The documentType describes any required and optional schema. Additionally, a binary  object may be stored on the document's content subresource and edge cached via the Mozu CDN.")
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class Document implements Serializable {
  private static final long serialVersionUID = 1L;

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private String id;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_PATH = "path";
  @SerializedName(SERIALIZED_NAME_PATH)
  private String path;

  public static final String SERIALIZED_NAME_PUBLISH_SET_CODE = "publishSetCode";
  @SerializedName(SERIALIZED_NAME_PUBLISH_SET_CODE)
  private String publishSetCode;

  public static final String SERIALIZED_NAME_EXTENSION = "extension";
  @SerializedName(SERIALIZED_NAME_EXTENSION)
  private String extension;

  public static final String SERIALIZED_NAME_DOCUMENT_TYPE_F_Q_N = "documentTypeFQN";
  @SerializedName(SERIALIZED_NAME_DOCUMENT_TYPE_F_Q_N)
  private String documentTypeFQN;

  public static final String SERIALIZED_NAME_LIST_F_Q_N = "listFQN";
  @SerializedName(SERIALIZED_NAME_LIST_F_Q_N)
  private String listFQN;

  public static final String SERIALIZED_NAME_CONTENT_LENGTH = "contentLength";
  @SerializedName(SERIALIZED_NAME_CONTENT_LENGTH)
  private Long contentLength;

  public static final String SERIALIZED_NAME_CONTENT_MIME_TYPE = "contentMimeType";
  @SerializedName(SERIALIZED_NAME_CONTENT_MIME_TYPE)
  private String contentMimeType;

  public static final String SERIALIZED_NAME_CONTENT_UPDATE_DATE = "contentUpdateDate";
  @SerializedName(SERIALIZED_NAME_CONTENT_UPDATE_DATE)
  private OffsetDateTime contentUpdateDate;

  public static final String SERIALIZED_NAME_PUBLISH_STATE = "publishState";
  @SerializedName(SERIALIZED_NAME_PUBLISH_STATE)
  private String publishState;

  public static final String SERIALIZED_NAME_PROPERTIES = "properties";
  @SerializedName(SERIALIZED_NAME_PROPERTIES)
  private Object properties = null;

  public static final String SERIALIZED_NAME_INSERT_DATE = "insertDate";
  @SerializedName(SERIALIZED_NAME_INSERT_DATE)
  private OffsetDateTime insertDate;

  public static final String SERIALIZED_NAME_UPDATE_DATE = "updateDate";
  @SerializedName(SERIALIZED_NAME_UPDATE_DATE)
  private OffsetDateTime updateDate;

  public static final String SERIALIZED_NAME_ACTIVE_DATE_RANGE = "activeDateRange";
  @SerializedName(SERIALIZED_NAME_ACTIVE_DATE_RANGE)
  private ContentActiveDateRange activeDateRange;

  public Document() {
  }

  public Document id(String id) {
    
    this.id = id;
    return this;
  }

   /**
   * Read-only, system generated 32 digit alpha-numeric string that uniquely identifies the document.
   * @return id
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Read-only, system generated 32 digit alpha-numeric string that uniquely identifies the document.")

  public String getId() {
    return id;
  }


  public void setId(String id) {
    this.id = id;
  }


  public Document name(String name) {
    
    this.name = name;
    return this;
  }

   /**
   * The fully qualified name of the document including path.  Unique within the documentList. This field is a required field, but it can be updated.
   * @return name
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The fully qualified name of the document including path.  Unique within the documentList. This field is a required field, but it can be updated.")

  public String getName() {
    return name;
  }


  public void setName(String name) {
    this.name = name;
  }


  public Document path(String path) {
    
    this.path = path;
    return this;
  }

   /**
   * ReadOnly, path portion of the Name property.
   * @return path
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "ReadOnly, path portion of the Name property.")

  public String getPath() {
    return path;
  }


  public void setPath(String path) {
    this.path = path;
  }


  public Document publishSetCode(String publishSetCode) {
    
    this.publishSetCode = publishSetCode;
    return this;
  }

   /**
   * The name of the publish set that this document belongs to, if any.
   * @return publishSetCode
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The name of the publish set that this document belongs to, if any.")

  public String getPublishSetCode() {
    return publishSetCode;
  }


  public void setPublishSetCode(String publishSetCode) {
    this.publishSetCode = publishSetCode;
  }


  public Document extension(String extension) {
    
    this.extension = extension;
    return this;
  }

   /**
   * If applicable, the file extension associated with the document content.
   * @return extension
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "If applicable, the file extension associated with the document content.")

  public String getExtension() {
    return extension;
  }


  public void setExtension(String extension) {
    this.extension = extension;
  }


  public Document documentTypeFQN(String documentTypeFQN) {
    
    this.documentTypeFQN = documentTypeFQN;
    return this;
  }

   /**
   * The full name of the documentType that underlies this document.  This field must be supplied upon document creation and cannot be updated.
   * @return documentTypeFQN
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The full name of the documentType that underlies this document.  This field must be supplied upon document creation and cannot be updated.")

  public String getDocumentTypeFQN() {
    return documentTypeFQN;
  }


  public void setDocumentTypeFQN(String documentTypeFQN) {
    this.documentTypeFQN = documentTypeFQN;
  }


  public Document listFQN(String listFQN) {
    
    this.listFQN = listFQN;
    return this;
  }

   /**
   * The fully qualified name of the documentList to which the document belongs.  This field is read-only and represents which documentList the document is created in.
   * @return listFQN
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The fully qualified name of the documentList to which the document belongs.  This field is read-only and represents which documentList the document is created in.")

  public String getListFQN() {
    return listFQN;
  }


  public void setListFQN(String listFQN) {
    this.listFQN = listFQN;
  }


  public Document contentLength(Long contentLength) {
    
    this.contentLength = contentLength;
    return this;
  }

   /**
   * The size of the content subresource in decimal number of OCTETs.  When updating the content subresource, the  contentLength is captured from the  Content-Length header, if present, or is otherwise computed from the total size of the http body.
   * @return contentLength
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The size of the content subresource in decimal number of OCTETs.  When updating the content subresource, the  contentLength is captured from the  Content-Length header, if present, or is otherwise computed from the total size of the http body.")

  public Long getContentLength() {
    return contentLength;
  }


  public void setContentLength(Long contentLength) {
    this.contentLength = contentLength;
  }


  public Document contentMimeType(String contentMimeType) {
    
    this.contentMimeType = contentMimeType;
    return this;
  }

   /**
   * The mime type of the document&#39;s binary content, provided via the Content-Type header when updating the content  subresource. If no value is provided then \&quot;application/octet-stream\&quot; is set by default.
   * @return contentMimeType
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The mime type of the document's binary content, provided via the Content-Type header when updating the content  subresource. If no value is provided then \"application/octet-stream\" is set by default.")

  public String getContentMimeType() {
    return contentMimeType;
  }


  public void setContentMimeType(String contentMimeType) {
    this.contentMimeType = contentMimeType;
  }


  public Document contentUpdateDate(OffsetDateTime contentUpdateDate) {
    
    this.contentUpdateDate = contentUpdateDate;
    return this;
  }

   /**
   * The date and time the most recent content update was made via the content subresource. UTC date/time.  System-supplied and read-only.
   * @return contentUpdateDate
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The date and time the most recent content update was made via the content subresource. UTC date/time.  System-supplied and read-only.")

  public OffsetDateTime getContentUpdateDate() {
    return contentUpdateDate;
  }


  public void setContentUpdateDate(OffsetDateTime contentUpdateDate) {
    this.contentUpdateDate = contentUpdateDate;
  }


  public Document publishState(String publishState) {
    
    this.publishState = publishState;
    return this;
  }

   /**
   * The current publish status of the document. If publishing is not supported or is currently disabled in the  documentList then the value will be \&quot;active\&quot;.  If publishing is supported and enabled, then the publish state may be \&quot;draft\&quot; or \&quot;active\&quot;. A document may have both  an \&quot;active\&quot; and \&quot;draft\&quot; version. The publishState  denotes which version of the document being interacted with. This field is read-only.
   * @return publishState
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The current publish status of the document. If publishing is not supported or is currently disabled in the  documentList then the value will be \"active\".  If publishing is supported and enabled, then the publish state may be \"draft\" or \"active\". A document may have both  an \"active\" and \"draft\" version. The publishState  denotes which version of the document being interacted with. This field is read-only.")

  public String getPublishState() {
    return publishState;
  }


  public void setPublishState(String publishState) {
    this.publishState = publishState;
  }


  public Document properties(Object properties) {
    
    this.properties = properties;
    return this;
  }

   /**
   * A JSON object of name/value pairs. Name parts are matched against the underlying documentType properties names. Any  matching name parts must have a value part that conforms to the matching property schema.  Any non-matching name/value pairs are considered dynamic schema and may have a value part of valid JSON.  The properties field can be used for sorting/filtering and can be projected in the documents returned within a  documentList view.
   * @return properties
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "A JSON object of name/value pairs. Name parts are matched against the underlying documentType properties names. Any  matching name parts must have a value part that conforms to the matching property schema.  Any non-matching name/value pairs are considered dynamic schema and may have a value part of valid JSON.  The properties field can be used for sorting/filtering and can be projected in the documents returned within a  documentList view.")

  public Object getProperties() {
    return properties;
  }


  public void setProperties(Object properties) {
    this.properties = properties;
  }


  public Document insertDate(OffsetDateTime insertDate) {
    
    this.insertDate = insertDate;
    return this;
  }

   /**
   * The date and time the document was added to the documentList. This field is system-supplied and read-only.
   * @return insertDate
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The date and time the document was added to the documentList. This field is system-supplied and read-only.")

  public OffsetDateTime getInsertDate() {
    return insertDate;
  }


  public void setInsertDate(OffsetDateTime insertDate) {
    this.insertDate = insertDate;
  }


  public Document updateDate(OffsetDateTime updateDate) {
    
    this.updateDate = updateDate;
    return this;
  }

   /**
   * The date and time the most recent document update was made. If publishing is enabled, then this value will  represent  the last draft update if the publishState is draft, or the last publish date if the publishState is active.
   * @return updateDate
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The date and time the most recent document update was made. If publishing is enabled, then this value will  represent  the last draft update if the publishState is draft, or the last publish date if the publishState is active.")

  public OffsetDateTime getUpdateDate() {
    return updateDate;
  }


  public void setUpdateDate(OffsetDateTime updateDate) {
    this.updateDate = updateDate;
  }


  public Document activeDateRange(ContentActiveDateRange activeDateRange) {
    
    this.activeDateRange = activeDateRange;
    return this;
  }

   /**
   * Get activeDateRange
   * @return activeDateRange
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public ContentActiveDateRange getActiveDateRange() {
    return activeDateRange;
  }


  public void setActiveDateRange(ContentActiveDateRange activeDateRange) {
    this.activeDateRange = activeDateRange;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Document document = (Document) o;
    return Objects.equals(this.id, document.id) &&
        Objects.equals(this.name, document.name) &&
        Objects.equals(this.path, document.path) &&
        Objects.equals(this.publishSetCode, document.publishSetCode) &&
        Objects.equals(this.extension, document.extension) &&
        Objects.equals(this.documentTypeFQN, document.documentTypeFQN) &&
        Objects.equals(this.listFQN, document.listFQN) &&
        Objects.equals(this.contentLength, document.contentLength) &&
        Objects.equals(this.contentMimeType, document.contentMimeType) &&
        Objects.equals(this.contentUpdateDate, document.contentUpdateDate) &&
        Objects.equals(this.publishState, document.publishState) &&
        Objects.equals(this.properties, document.properties) &&
        Objects.equals(this.insertDate, document.insertDate) &&
        Objects.equals(this.updateDate, document.updateDate) &&
        Objects.equals(this.activeDateRange, document.activeDateRange);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(id, name, path, publishSetCode, extension, documentTypeFQN, listFQN, contentLength, contentMimeType, contentUpdateDate, publishState, properties, insertDate, updateDate, activeDateRange);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Document {\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    path: ").append(toIndentedString(path)).append("\n");
    sb.append("    publishSetCode: ").append(toIndentedString(publishSetCode)).append("\n");
    sb.append("    extension: ").append(toIndentedString(extension)).append("\n");
    sb.append("    documentTypeFQN: ").append(toIndentedString(documentTypeFQN)).append("\n");
    sb.append("    listFQN: ").append(toIndentedString(listFQN)).append("\n");
    sb.append("    contentLength: ").append(toIndentedString(contentLength)).append("\n");
    sb.append("    contentMimeType: ").append(toIndentedString(contentMimeType)).append("\n");
    sb.append("    contentUpdateDate: ").append(toIndentedString(contentUpdateDate)).append("\n");
    sb.append("    publishState: ").append(toIndentedString(publishState)).append("\n");
    sb.append("    properties: ").append(toIndentedString(properties)).append("\n");
    sb.append("    insertDate: ").append(toIndentedString(insertDate)).append("\n");
    sb.append("    updateDate: ").append(toIndentedString(updateDate)).append("\n");
    sb.append("    activeDateRange: ").append(toIndentedString(activeDateRange)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("id");
    openapiFields.add("name");
    openapiFields.add("path");
    openapiFields.add("publishSetCode");
    openapiFields.add("extension");
    openapiFields.add("documentTypeFQN");
    openapiFields.add("listFQN");
    openapiFields.add("contentLength");
    openapiFields.add("contentMimeType");
    openapiFields.add("contentUpdateDate");
    openapiFields.add("publishState");
    openapiFields.add("properties");
    openapiFields.add("insertDate");
    openapiFields.add("updateDate");
    openapiFields.add("activeDateRange");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to Document
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!Document.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Document is not found in the empty JSON string", Document.openapiRequiredFields.toString()));
        }
      }

      // Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      // for (Entry<String, JsonElement> entry : entries) {
      //  if (!Document.openapiFields.contains(entry.getKey())) {
      //    throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Document` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
      //    }
      //  }
      
      if ((jsonObj.get("id") != null && !jsonObj.get("id").isJsonNull()) && !jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if ((jsonObj.get("path") != null && !jsonObj.get("path").isJsonNull()) && !jsonObj.get("path").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `path` to be a primitive type in the JSON string but got `%s`", jsonObj.get("path").toString()));
      }
      if ((jsonObj.get("publishSetCode") != null && !jsonObj.get("publishSetCode").isJsonNull()) && !jsonObj.get("publishSetCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `publishSetCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("publishSetCode").toString()));
      }
      if ((jsonObj.get("extension") != null && !jsonObj.get("extension").isJsonNull()) && !jsonObj.get("extension").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `extension` to be a primitive type in the JSON string but got `%s`", jsonObj.get("extension").toString()));
      }
      if ((jsonObj.get("documentTypeFQN") != null && !jsonObj.get("documentTypeFQN").isJsonNull()) && !jsonObj.get("documentTypeFQN").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `documentTypeFQN` to be a primitive type in the JSON string but got `%s`", jsonObj.get("documentTypeFQN").toString()));
      }
      if ((jsonObj.get("listFQN") != null && !jsonObj.get("listFQN").isJsonNull()) && !jsonObj.get("listFQN").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `listFQN` to be a primitive type in the JSON string but got `%s`", jsonObj.get("listFQN").toString()));
      }
      if ((jsonObj.get("contentMimeType") != null && !jsonObj.get("contentMimeType").isJsonNull()) && !jsonObj.get("contentMimeType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `contentMimeType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("contentMimeType").toString()));
      }
      if ((jsonObj.get("publishState") != null && !jsonObj.get("publishState").isJsonNull()) && !jsonObj.get("publishState").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `publishState` to be a primitive type in the JSON string but got `%s`", jsonObj.get("publishState").toString()));
      }
      // validate the optional field `activeDateRange`
      if (jsonObj.get("activeDateRange") != null && !jsonObj.get("activeDateRange").isJsonNull()) {
        ContentActiveDateRange.validateJsonObject(jsonObj.getAsJsonObject("activeDateRange"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Document.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Document' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Document> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Document.class));

       return (TypeAdapter<T>) new TypeAdapter<Document>() {
           @Override
           public void write(JsonWriter out, Document value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Document read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of Document given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of Document
  * @throws IOException if the JSON string is invalid with respect to Document
  */
  public static Document fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Document.class);
  }

 /**
  * Convert an instance of Document to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

