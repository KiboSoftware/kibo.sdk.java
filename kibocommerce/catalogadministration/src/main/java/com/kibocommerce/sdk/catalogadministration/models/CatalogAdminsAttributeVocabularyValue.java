/*
 * Kibo Catalog Admin Services
 * OpenAPI Spec for Kibo Catalog Admin Services
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.kibocommerce.sdk.catalogadministration.models;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.kibocommerce.sdk.catalogadministration.models.AttributeVocabularyValueLocalizedContent;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import org.openapitools.jackson.nullable.JsonNullable;
import java.io.Serializable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.kibocommerce.sdk.common.JSON;

/**
 * Value of an attribute
 */
@ApiModel(description = "Value of an attribute")
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class CatalogAdminsAttributeVocabularyValue implements Serializable {
  private static final long serialVersionUID = 1L;

  public static final String SERIALIZED_NAME_VALUE_SEQUENCE = "valueSequence";
  @SerializedName(SERIALIZED_NAME_VALUE_SEQUENCE)
  private Integer valueSequence;

  public static final String SERIALIZED_NAME_VALUE = "value";
  @SerializedName(SERIALIZED_NAME_VALUE)
  private Object value = null;

  public static final String SERIALIZED_NAME_MAPPED_GENERIC_VALUES = "mappedGenericValues";
  @SerializedName(SERIALIZED_NAME_MAPPED_GENERIC_VALUES)
  private List<Object> mappedGenericValues = null;

  public static final String SERIALIZED_NAME_PRODUCT_NAME = "productName";
  @SerializedName(SERIALIZED_NAME_PRODUCT_NAME)
  private String productName;

  public static final String SERIALIZED_NAME_CONTENT = "content";
  @SerializedName(SERIALIZED_NAME_CONTENT)
  private AttributeVocabularyValueLocalizedContent content;

  public static final String SERIALIZED_NAME_LOCALIZED_CONTENT = "localizedContent";
  @SerializedName(SERIALIZED_NAME_LOCALIZED_CONTENT)
  private List<AttributeVocabularyValueLocalizedContent> localizedContent = null;

  public static final String SERIALIZED_NAME_DISPLAY_ORDER = "displayOrder";
  @SerializedName(SERIALIZED_NAME_DISPLAY_ORDER)
  private Integer displayOrder;

  public CatalogAdminsAttributeVocabularyValue() {
  }

  public CatalogAdminsAttributeVocabularyValue valueSequence(Integer valueSequence) {
    
    this.valueSequence = valueSequence;
    return this;
  }

   /**
   * Read only System generated monotonically increasing unique sequence.
   * @return valueSequence
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Read only System generated monotonically increasing unique sequence.")

  public Integer getValueSequence() {
    return valueSequence;
  }


  public void setValueSequence(Integer valueSequence) {
    this.valueSequence = valueSequence;
  }


  public CatalogAdminsAttributeVocabularyValue value(Object value) {
    
    this.value = value;
    return this;
  }

   /**
   * The actual value of the attribute vocabulary. This value must be unique within the vocabulary for a single attribute and match the datatype of the attribute.   String data type requires a canonical value here or one will be system generated if null. The actual string content displayed to users should be stored as Content.   String values require content to be present.  Once this value is set it cannot be changed.
   * @return value
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The actual value of the attribute vocabulary. This value must be unique within the vocabulary for a single attribute and match the datatype of the attribute.   String data type requires a canonical value here or one will be system generated if null. The actual string content displayed to users should be stored as Content.   String values require content to be present.  Once this value is set it cannot be changed.")

  public Object getValue() {
    return value;
  }


  public void setValue(Object value) {
    this.value = value;
  }


  public CatalogAdminsAttributeVocabularyValue mappedGenericValues(List<Object> mappedGenericValues) {
    
    this.mappedGenericValues = mappedGenericValues;
    return this;
  }

  public CatalogAdminsAttributeVocabularyValue addMappedGenericValuesItem(Object mappedGenericValuesItem) {
    if (this.mappedGenericValues == null) {
      this.mappedGenericValues = new ArrayList<>();
    }
    this.mappedGenericValues.add(mappedGenericValuesItem);
    return this;
  }

   /**
   * The actual values of the related generic attribute. This value must match the datatype of the attribute and already exist   within the Vocabulary values of the related ValueMappingAttribute. Only supporting string at this time.
   * @return mappedGenericValues
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The actual values of the related generic attribute. This value must match the datatype of the attribute and already exist   within the Vocabulary values of the related ValueMappingAttribute. Only supporting string at this time.")

  public List<Object> getMappedGenericValues() {
    return mappedGenericValues;
  }


  public void setMappedGenericValues(List<Object> mappedGenericValues) {
    this.mappedGenericValues = mappedGenericValues;
  }


  public CatalogAdminsAttributeVocabularyValue productName(String productName) {
    
    this.productName = productName;
    return this;
  }

   /**
   * The ProductName when the Attribute DataType is ProductCode.
   * @return productName
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The ProductName when the Attribute DataType is ProductCode.")

  public String getProductName() {
    return productName;
  }


  public void setProductName(String productName) {
    this.productName = productName;
  }


  public CatalogAdminsAttributeVocabularyValue content(AttributeVocabularyValueLocalizedContent content) {
    
    this.content = content;
    return this;
  }

   /**
   * Get content
   * @return content
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public AttributeVocabularyValueLocalizedContent getContent() {
    return content;
  }


  public void setContent(AttributeVocabularyValueLocalizedContent content) {
    this.content = content;
  }


  public CatalogAdminsAttributeVocabularyValue localizedContent(List<AttributeVocabularyValueLocalizedContent> localizedContent) {
    
    this.localizedContent = localizedContent;
    return this;
  }

  public CatalogAdminsAttributeVocabularyValue addLocalizedContentItem(AttributeVocabularyValueLocalizedContent localizedContentItem) {
    if (this.localizedContent == null) {
      this.localizedContent = new ArrayList<>();
    }
    this.localizedContent.add(localizedContentItem);
    return this;
  }

   /**
   * The Content of an attribute value. This content is in multiple locals supported by the master catalog and is only valid for String DataType.
   * @return localizedContent
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The Content of an attribute value. This content is in multiple locals supported by the master catalog and is only valid for String DataType.")

  public List<AttributeVocabularyValueLocalizedContent> getLocalizedContent() {
    return localizedContent;
  }


  public void setLocalizedContent(List<AttributeVocabularyValueLocalizedContent> localizedContent) {
    this.localizedContent = localizedContent;
  }


  public CatalogAdminsAttributeVocabularyValue displayOrder(Integer displayOrder) {
    
    this.displayOrder = displayOrder;
    return this;
  }

   /**
   * The order in which the attribute value displays. If you omit a value for this property, Mozu infers the display order from the attribute value&#39;s position the list.
   * @return displayOrder
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The order in which the attribute value displays. If you omit a value for this property, Mozu infers the display order from the attribute value's position the list.")

  public Integer getDisplayOrder() {
    return displayOrder;
  }


  public void setDisplayOrder(Integer displayOrder) {
    this.displayOrder = displayOrder;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    CatalogAdminsAttributeVocabularyValue catalogAdminsAttributeVocabularyValue = (CatalogAdminsAttributeVocabularyValue) o;
    return Objects.equals(this.valueSequence, catalogAdminsAttributeVocabularyValue.valueSequence) &&
        Objects.equals(this.value, catalogAdminsAttributeVocabularyValue.value) &&
        Objects.equals(this.mappedGenericValues, catalogAdminsAttributeVocabularyValue.mappedGenericValues) &&
        Objects.equals(this.productName, catalogAdminsAttributeVocabularyValue.productName) &&
        Objects.equals(this.content, catalogAdminsAttributeVocabularyValue.content) &&
        Objects.equals(this.localizedContent, catalogAdminsAttributeVocabularyValue.localizedContent) &&
        Objects.equals(this.displayOrder, catalogAdminsAttributeVocabularyValue.displayOrder);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(valueSequence, value, mappedGenericValues, productName, content, localizedContent, displayOrder);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class CatalogAdminsAttributeVocabularyValue {\n");
    sb.append("    valueSequence: ").append(toIndentedString(valueSequence)).append("\n");
    sb.append("    value: ").append(toIndentedString(value)).append("\n");
    sb.append("    mappedGenericValues: ").append(toIndentedString(mappedGenericValues)).append("\n");
    sb.append("    productName: ").append(toIndentedString(productName)).append("\n");
    sb.append("    content: ").append(toIndentedString(content)).append("\n");
    sb.append("    localizedContent: ").append(toIndentedString(localizedContent)).append("\n");
    sb.append("    displayOrder: ").append(toIndentedString(displayOrder)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("valueSequence");
    openapiFields.add("value");
    openapiFields.add("mappedGenericValues");
    openapiFields.add("productName");
    openapiFields.add("content");
    openapiFields.add("localizedContent");
    openapiFields.add("displayOrder");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to CatalogAdminsAttributeVocabularyValue
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!CatalogAdminsAttributeVocabularyValue.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in CatalogAdminsAttributeVocabularyValue is not found in the empty JSON string", CatalogAdminsAttributeVocabularyValue.openapiRequiredFields.toString()));
        }
      }

      // Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      // for (Entry<String, JsonElement> entry : entries) {
      //  if (!CatalogAdminsAttributeVocabularyValue.openapiFields.contains(entry.getKey())) {
      //    throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `CatalogAdminsAttributeVocabularyValue` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
      //    }
      //  }
      
      // ensure the json data is an array
      if (!jsonObj.get("mappedGenericValues").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `mappedGenericValues` to be an array in the JSON string but got `%s`", jsonObj.get("mappedGenericValues").toString()));
      }
      if ((jsonObj.get("productName") != null && !jsonObj.get("productName").isJsonNull()) && !jsonObj.get("productName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `productName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("productName").toString()));
      }
      // validate the optional field `content`
      if (jsonObj.get("content") != null && !jsonObj.get("content").isJsonNull()) {
        AttributeVocabularyValueLocalizedContent.validateJsonObject(jsonObj.getAsJsonObject("content"));
      }
      if (jsonObj.get("localizedContent") != null && !jsonObj.get("localizedContent").isJsonNull()) {
        JsonArray jsonArraylocalizedContent = jsonObj.getAsJsonArray("localizedContent");
        if (jsonArraylocalizedContent != null) {
          // ensure the json data is an array
          if (!jsonObj.get("localizedContent").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `localizedContent` to be an array in the JSON string but got `%s`", jsonObj.get("localizedContent").toString()));
          }

          // validate the optional field `localizedContent` (array)
          for (int i = 0; i < jsonArraylocalizedContent.size(); i++) {
            AttributeVocabularyValueLocalizedContent.validateJsonObject(jsonArraylocalizedContent.get(i).getAsJsonObject());
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!CatalogAdminsAttributeVocabularyValue.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'CatalogAdminsAttributeVocabularyValue' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<CatalogAdminsAttributeVocabularyValue> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(CatalogAdminsAttributeVocabularyValue.class));

       return (TypeAdapter<T>) new TypeAdapter<CatalogAdminsAttributeVocabularyValue>() {
           @Override
           public void write(JsonWriter out, CatalogAdminsAttributeVocabularyValue value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public CatalogAdminsAttributeVocabularyValue read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of CatalogAdminsAttributeVocabularyValue given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of CatalogAdminsAttributeVocabularyValue
  * @throws IOException if the JSON string is invalid with respect to CatalogAdminsAttributeVocabularyValue
  */
  public static CatalogAdminsAttributeVocabularyValue fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, CatalogAdminsAttributeVocabularyValue.class);
  }

 /**
  * Convert an instance of CatalogAdminsAttributeVocabularyValue to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

