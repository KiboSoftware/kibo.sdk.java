/*
 * Kibo MZDB Service
 * OpenAPI Spec for Kibo MZDB Service
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.kibocommerce.sdk.entities.models;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.kibocommerce.sdk.entities.models.IndexedProperty;
import com.kibocommerce.sdk.entities.models.ListView;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.List;
import org.openapitools.jackson.nullable.JsonNullable;
import java.io.Serializable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.kibocommerce.sdk.common.JSON;

/**
 * The definition of an MZDB EntityList which describes the characteristics of the EntityList on a per tenant basis. EntityLists are created at the tenant level, but instances of the EntityLists are implicitly created at the appropriate context level as entities are added or removed from the EntityList.
 */
@ApiModel(description = "The definition of an MZDB EntityList which describes the characteristics of the EntityList on a per tenant basis. EntityLists are created at the tenant level, but instances of the EntityLists are implicitly created at the appropriate context level as entities are added or removed from the EntityList.")
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class EntityList implements Serializable {
  private static final long serialVersionUID = 1L;

  public static final String SERIALIZED_NAME_TENANT_ID = "tenantId";
  @SerializedName(SERIALIZED_NAME_TENANT_ID)
  private Integer tenantId;

  public static final String SERIALIZED_NAME_NAME_SPACE = "nameSpace";
  @SerializedName(SERIALIZED_NAME_NAME_SPACE)
  private String nameSpace;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_CONTEXT_LEVEL = "contextLevel";
  @SerializedName(SERIALIZED_NAME_CONTEXT_LEVEL)
  private String contextLevel;

  public static final String SERIALIZED_NAME_USE_SYSTEM_ASSIGNED_ID = "useSystemAssignedId";
  @SerializedName(SERIALIZED_NAME_USE_SYSTEM_ASSIGNED_ID)
  private Boolean useSystemAssignedId;

  public static final String SERIALIZED_NAME_ID_PROPERTY = "idProperty";
  @SerializedName(SERIALIZED_NAME_ID_PROPERTY)
  private IndexedProperty idProperty;

  public static final String SERIALIZED_NAME_INDEX_A = "indexA";
  @SerializedName(SERIALIZED_NAME_INDEX_A)
  private IndexedProperty indexA;

  public static final String SERIALIZED_NAME_INDEX_B = "indexB";
  @SerializedName(SERIALIZED_NAME_INDEX_B)
  private IndexedProperty indexB;

  public static final String SERIALIZED_NAME_INDEX_C = "indexC";
  @SerializedName(SERIALIZED_NAME_INDEX_C)
  private IndexedProperty indexC;

  public static final String SERIALIZED_NAME_INDEX_D = "indexD";
  @SerializedName(SERIALIZED_NAME_INDEX_D)
  private IndexedProperty indexD;

  public static final String SERIALIZED_NAME_IS_VISIBLE_IN_STOREFRONT = "isVisibleInStorefront";
  @SerializedName(SERIALIZED_NAME_IS_VISIBLE_IN_STOREFRONT)
  private Boolean isVisibleInStorefront;

  public static final String SERIALIZED_NAME_IS_LOCALE_SPECIFIC = "isLocaleSpecific";
  @SerializedName(SERIALIZED_NAME_IS_LOCALE_SPECIFIC)
  private Boolean isLocaleSpecific;

  public static final String SERIALIZED_NAME_IS_SHOPPER_SPECIFIC = "isShopperSpecific";
  @SerializedName(SERIALIZED_NAME_IS_SHOPPER_SPECIFIC)
  private Boolean isShopperSpecific;

  public static final String SERIALIZED_NAME_IS_SANDBOX_DATA_CLONING_SUPPORTED = "isSandboxDataCloningSupported";
  @SerializedName(SERIALIZED_NAME_IS_SANDBOX_DATA_CLONING_SUPPORTED)
  private Boolean isSandboxDataCloningSupported;

  public static final String SERIALIZED_NAME_VIEWS = "views";
  @SerializedName(SERIALIZED_NAME_VIEWS)
  private List<ListView> views = null;

  public static final String SERIALIZED_NAME_USAGES = "usages";
  @SerializedName(SERIALIZED_NAME_USAGES)
  private List<String> usages = null;

  public static final String SERIALIZED_NAME_METADATA = "metadata";
  @SerializedName(SERIALIZED_NAME_METADATA)
  private Object metadata = null;

  public static final String SERIALIZED_NAME_CREATE_DATE = "createDate";
  @SerializedName(SERIALIZED_NAME_CREATE_DATE)
  private OffsetDateTime createDate;

  public static final String SERIALIZED_NAME_UPDATE_DATE = "updateDate";
  @SerializedName(SERIALIZED_NAME_UPDATE_DATE)
  private OffsetDateTime updateDate;

  public EntityList() {
  }

  public EntityList tenantId(Integer tenantId) {
    
    this.tenantId = tenantId;
    return this;
  }

   /**
   * Get tenantId
   * @return tenantId
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public Integer getTenantId() {
    return tenantId;
  }


  public void setTenantId(Integer tenantId) {
    this.tenantId = tenantId;
  }


  public EntityList nameSpace(String nameSpace) {
    
    this.nameSpace = nameSpace;
    return this;
  }

   /**
   * The nameSpace for the EntityList which must be within the nameSpace scope of the developer Account for the creating application.  The name and namespace are formatted as name@nameSpace when specified as fullName. An EntityLists fullName must be unique within the tenant in which it is created.
   * @return nameSpace
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The nameSpace for the EntityList which must be within the nameSpace scope of the developer Account for the creating application.  The name and namespace are formatted as name@nameSpace when specified as fullName. An EntityLists fullName must be unique within the tenant in which it is created.")

  public String getNameSpace() {
    return nameSpace;
  }


  public void setNameSpace(String nameSpace) {
    this.nameSpace = nameSpace;
  }


  public EntityList name(String name) {
    
    this.name = name;
    return this;
  }

   /**
   * The name for the EntityList which must be unique within the namespace provided.  The name and namespace are formatted as name@nameSpace when specified as fullName. An EntityLists fullName must be unique within the tenant in which it is created.
   * @return name
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The name for the EntityList which must be unique within the namespace provided.  The name and namespace are formatted as name@nameSpace when specified as fullName. An EntityLists fullName must be unique within the tenant in which it is created.")

  public String getName() {
    return name;
  }


  public void setName(String name) {
    this.name = name;
  }


  public EntityList contextLevel(String contextLevel) {
    
    this.contextLevel = contextLevel;
    return this;
  }

   /**
   * At which context level are entities stored in the list. Possible values are \&quot;tenant\&quot;, \&quot;site\&quot;, \&quot;masterCatalog\&quot; or \&quot;catalog\&quot;.  Each list instance will exist at this context level for the tenant.
   * @return contextLevel
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "At which context level are entities stored in the list. Possible values are \"tenant\", \"site\", \"masterCatalog\" or \"catalog\".  Each list instance will exist at this context level for the tenant.")

  public String getContextLevel() {
    return contextLevel;
  }


  public void setContextLevel(String contextLevel) {
    this.contextLevel = contextLevel;
  }


  public EntityList useSystemAssignedId(Boolean useSystemAssignedId) {
    
    this.useSystemAssignedId = useSystemAssignedId;
    return this;
  }

   /**
   * Indicates whether or not Mozu should assign a generated identifier for each entity in the list or whether a unique identifier will be provided for each identity. If set to false, then a value must be provided for the IdProperty for the list.
   * @return useSystemAssignedId
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Indicates whether or not Mozu should assign a generated identifier for each entity in the list or whether a unique identifier will be provided for each identity. If set to false, then a value must be provided for the IdProperty for the list.")

  public Boolean getUseSystemAssignedId() {
    return useSystemAssignedId;
  }


  public void setUseSystemAssignedId(Boolean useSystemAssignedId) {
    this.useSystemAssignedId = useSystemAssignedId;
  }


  public EntityList idProperty(IndexedProperty idProperty) {
    
    this.idProperty = idProperty;
    return this;
  }

   /**
   * Get idProperty
   * @return idProperty
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public IndexedProperty getIdProperty() {
    return idProperty;
  }


  public void setIdProperty(IndexedProperty idProperty) {
    this.idProperty = idProperty;
  }


  public EntityList indexA(IndexedProperty indexA) {
    
    this.indexA = indexA;
    return this;
  }

   /**
   * Get indexA
   * @return indexA
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public IndexedProperty getIndexA() {
    return indexA;
  }


  public void setIndexA(IndexedProperty indexA) {
    this.indexA = indexA;
  }


  public EntityList indexB(IndexedProperty indexB) {
    
    this.indexB = indexB;
    return this;
  }

   /**
   * Get indexB
   * @return indexB
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public IndexedProperty getIndexB() {
    return indexB;
  }


  public void setIndexB(IndexedProperty indexB) {
    this.indexB = indexB;
  }


  public EntityList indexC(IndexedProperty indexC) {
    
    this.indexC = indexC;
    return this;
  }

   /**
   * Get indexC
   * @return indexC
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public IndexedProperty getIndexC() {
    return indexC;
  }


  public void setIndexC(IndexedProperty indexC) {
    this.indexC = indexC;
  }


  public EntityList indexD(IndexedProperty indexD) {
    
    this.indexD = indexD;
    return this;
  }

   /**
   * Get indexD
   * @return indexD
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public IndexedProperty getIndexD() {
    return indexD;
  }


  public void setIndexD(IndexedProperty indexD) {
    this.indexD = indexD;
  }


  public EntityList isVisibleInStorefront(Boolean isVisibleInStorefront) {
    
    this.isVisibleInStorefront = isVisibleInStorefront;
    return this;
  }

   /**
   * Indicates whether Enitities in the EntityList are allowed to be accessed from a Mozu storefront.
   * @return isVisibleInStorefront
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Indicates whether Enitities in the EntityList are allowed to be accessed from a Mozu storefront.")

  public Boolean getIsVisibleInStorefront() {
    return isVisibleInStorefront;
  }


  public void setIsVisibleInStorefront(Boolean isVisibleInStorefront) {
    this.isVisibleInStorefront = isVisibleInStorefront;
  }


  public EntityList isLocaleSpecific(Boolean isLocaleSpecific) {
    
    this.isLocaleSpecific = isLocaleSpecific;
    return this;
  }

   /**
   * Indicates whether MZDB should store entities in the EntityList instance specific to the localeCode provided.  If true, all operations on the EntityList will be filtered by the provided localeCode on the request or using the defautLocaleCode for the context.  All entities created in the EntityList will be stored with the localeCode provided on the request or the defautLocaleCode for the context as an additional implicit key. The default value is false.
   * @return isLocaleSpecific
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Indicates whether MZDB should store entities in the EntityList instance specific to the localeCode provided.  If true, all operations on the EntityList will be filtered by the provided localeCode on the request or using the defautLocaleCode for the context.  All entities created in the EntityList will be stored with the localeCode provided on the request or the defautLocaleCode for the context as an additional implicit key. The default value is false.")

  public Boolean getIsLocaleSpecific() {
    return isLocaleSpecific;
  }


  public void setIsLocaleSpecific(Boolean isLocaleSpecific) {
    this.isLocaleSpecific = isLocaleSpecific;
  }


  public EntityList isShopperSpecific(Boolean isShopperSpecific) {
    
    this.isShopperSpecific = isShopperSpecific;
    return this;
  }

   /**
   * Indicates whether MZDB should store entities in the EntityList instance specific to the current shopper on the request.  If true, all operations on the EntityList will be filtered by the id of the shopper from the shopper claims provided on the request.  All entities created in the EntityList will be stored with the id of the shopper from the shopper claims provided on the request as an additional implicit key. The default value is false.
   * @return isShopperSpecific
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Indicates whether MZDB should store entities in the EntityList instance specific to the current shopper on the request.  If true, all operations on the EntityList will be filtered by the id of the shopper from the shopper claims provided on the request.  All entities created in the EntityList will be stored with the id of the shopper from the shopper claims provided on the request as an additional implicit key. The default value is false.")

  public Boolean getIsShopperSpecific() {
    return isShopperSpecific;
  }


  public void setIsShopperSpecific(Boolean isShopperSpecific) {
    this.isShopperSpecific = isShopperSpecific;
  }


  public EntityList isSandboxDataCloningSupported(Boolean isSandboxDataCloningSupported) {
    
    this.isSandboxDataCloningSupported = isSandboxDataCloningSupported;
    return this;
  }

   /**
   * Indicates whether MZDB should clone all of the Entities in the EntityList when cloning an existing sandbox for which this list is already defined.  The default value is false.
   * @return isSandboxDataCloningSupported
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Indicates whether MZDB should clone all of the Entities in the EntityList when cloning an existing sandbox for which this list is already defined.  The default value is false.")

  public Boolean getIsSandboxDataCloningSupported() {
    return isSandboxDataCloningSupported;
  }


  public void setIsSandboxDataCloningSupported(Boolean isSandboxDataCloningSupported) {
    this.isSandboxDataCloningSupported = isSandboxDataCloningSupported;
  }


  public EntityList views(List<ListView> views) {
    
    this.views = views;
    return this;
  }

  public EntityList addViewsItem(ListView viewsItem) {
    if (this.views == null) {
      this.views = new ArrayList<>();
    }
    this.views.add(viewsItem);
    return this;
  }

   /**
   * The ListViews defined for this EntityList.  ListViews may be used to automatically filter an EntityList or transform the Entities in the list to a new Schema.
   * @return views
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The ListViews defined for this EntityList.  ListViews may be used to automatically filter an EntityList or transform the Entities in the list to a new Schema.")

  public List<ListView> getViews() {
    return views;
  }


  public void setViews(List<ListView> views) {
    this.views = views;
  }


  public EntityList usages(List<String> usages) {
    
    this.usages = usages;
    return this;
  }

  public EntityList addUsagesItem(String usagesItem) {
    if (this.usages == null) {
      this.usages = new ArrayList<>();
    }
    this.usages.add(usagesItem);
    return this;
  }

   /**
   * Usages are arbitratry sting values used to provide instructions for other applications as to the intended areas where the list should be used. Mozu uses the \&quot;admin\&quot; usage valued to indicate that an EntityList should appear in the EntityManager in the Admin UI.  The values are open ended and applications may provide any value for a usage. This field can be used in queries to the EntityList.
   * @return usages
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Usages are arbitratry sting values used to provide instructions for other applications as to the intended areas where the list should be used. Mozu uses the \"admin\" usage valued to indicate that an EntityList should appear in the EntityManager in the Admin UI.  The values are open ended and applications may provide any value for a usage. This field can be used in queries to the EntityList.")

  public List<String> getUsages() {
    return usages;
  }


  public void setUsages(List<String> usages) {
    this.usages = usages;
  }


  public EntityList metadata(Object metadata) {
    
    this.metadata = metadata;
    return this;
  }

   /**
   * An arbitrary json property to be used by external applications for any purpose. MZDB will persist and retrieve the metadata without any restrictions.
   * @return metadata
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "An arbitrary json property to be used by external applications for any purpose. MZDB will persist and retrieve the metadata without any restrictions.")

  public Object getMetadata() {
    return metadata;
  }


  public void setMetadata(Object metadata) {
    this.metadata = metadata;
  }


  public EntityList createDate(OffsetDateTime createDate) {
    
    this.createDate = createDate;
    return this;
  }

   /**
   * Get createDate
   * @return createDate
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public OffsetDateTime getCreateDate() {
    return createDate;
  }


  public void setCreateDate(OffsetDateTime createDate) {
    this.createDate = createDate;
  }


  public EntityList updateDate(OffsetDateTime updateDate) {
    
    this.updateDate = updateDate;
    return this;
  }

   /**
   * Get updateDate
   * @return updateDate
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public OffsetDateTime getUpdateDate() {
    return updateDate;
  }


  public void setUpdateDate(OffsetDateTime updateDate) {
    this.updateDate = updateDate;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    EntityList entityList = (EntityList) o;
    return Objects.equals(this.tenantId, entityList.tenantId) &&
        Objects.equals(this.nameSpace, entityList.nameSpace) &&
        Objects.equals(this.name, entityList.name) &&
        Objects.equals(this.contextLevel, entityList.contextLevel) &&
        Objects.equals(this.useSystemAssignedId, entityList.useSystemAssignedId) &&
        Objects.equals(this.idProperty, entityList.idProperty) &&
        Objects.equals(this.indexA, entityList.indexA) &&
        Objects.equals(this.indexB, entityList.indexB) &&
        Objects.equals(this.indexC, entityList.indexC) &&
        Objects.equals(this.indexD, entityList.indexD) &&
        Objects.equals(this.isVisibleInStorefront, entityList.isVisibleInStorefront) &&
        Objects.equals(this.isLocaleSpecific, entityList.isLocaleSpecific) &&
        Objects.equals(this.isShopperSpecific, entityList.isShopperSpecific) &&
        Objects.equals(this.isSandboxDataCloningSupported, entityList.isSandboxDataCloningSupported) &&
        Objects.equals(this.views, entityList.views) &&
        Objects.equals(this.usages, entityList.usages) &&
        Objects.equals(this.metadata, entityList.metadata) &&
        Objects.equals(this.createDate, entityList.createDate) &&
        Objects.equals(this.updateDate, entityList.updateDate);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(tenantId, nameSpace, name, contextLevel, useSystemAssignedId, idProperty, indexA, indexB, indexC, indexD, isVisibleInStorefront, isLocaleSpecific, isShopperSpecific, isSandboxDataCloningSupported, views, usages, metadata, createDate, updateDate);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class EntityList {\n");
    sb.append("    tenantId: ").append(toIndentedString(tenantId)).append("\n");
    sb.append("    nameSpace: ").append(toIndentedString(nameSpace)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    contextLevel: ").append(toIndentedString(contextLevel)).append("\n");
    sb.append("    useSystemAssignedId: ").append(toIndentedString(useSystemAssignedId)).append("\n");
    sb.append("    idProperty: ").append(toIndentedString(idProperty)).append("\n");
    sb.append("    indexA: ").append(toIndentedString(indexA)).append("\n");
    sb.append("    indexB: ").append(toIndentedString(indexB)).append("\n");
    sb.append("    indexC: ").append(toIndentedString(indexC)).append("\n");
    sb.append("    indexD: ").append(toIndentedString(indexD)).append("\n");
    sb.append("    isVisibleInStorefront: ").append(toIndentedString(isVisibleInStorefront)).append("\n");
    sb.append("    isLocaleSpecific: ").append(toIndentedString(isLocaleSpecific)).append("\n");
    sb.append("    isShopperSpecific: ").append(toIndentedString(isShopperSpecific)).append("\n");
    sb.append("    isSandboxDataCloningSupported: ").append(toIndentedString(isSandboxDataCloningSupported)).append("\n");
    sb.append("    views: ").append(toIndentedString(views)).append("\n");
    sb.append("    usages: ").append(toIndentedString(usages)).append("\n");
    sb.append("    metadata: ").append(toIndentedString(metadata)).append("\n");
    sb.append("    createDate: ").append(toIndentedString(createDate)).append("\n");
    sb.append("    updateDate: ").append(toIndentedString(updateDate)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("tenantId");
    openapiFields.add("nameSpace");
    openapiFields.add("name");
    openapiFields.add("contextLevel");
    openapiFields.add("useSystemAssignedId");
    openapiFields.add("idProperty");
    openapiFields.add("indexA");
    openapiFields.add("indexB");
    openapiFields.add("indexC");
    openapiFields.add("indexD");
    openapiFields.add("isVisibleInStorefront");
    openapiFields.add("isLocaleSpecific");
    openapiFields.add("isShopperSpecific");
    openapiFields.add("isSandboxDataCloningSupported");
    openapiFields.add("views");
    openapiFields.add("usages");
    openapiFields.add("metadata");
    openapiFields.add("createDate");
    openapiFields.add("updateDate");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to EntityList
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!EntityList.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in EntityList is not found in the empty JSON string", EntityList.openapiRequiredFields.toString()));
        }
      }

      // Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      // for (Entry<String, JsonElement> entry : entries) {
      //  if (!EntityList.openapiFields.contains(entry.getKey())) {
      //    throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `EntityList` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
      //    }
      //  }
      
      if ((jsonObj.get("nameSpace") != null && !jsonObj.get("nameSpace").isJsonNull()) && !jsonObj.get("nameSpace").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `nameSpace` to be a primitive type in the JSON string but got `%s`", jsonObj.get("nameSpace").toString()));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if ((jsonObj.get("contextLevel") != null && !jsonObj.get("contextLevel").isJsonNull()) && !jsonObj.get("contextLevel").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `contextLevel` to be a primitive type in the JSON string but got `%s`", jsonObj.get("contextLevel").toString()));
      }
      // validate the optional field `idProperty`
      if (jsonObj.get("idProperty") != null && !jsonObj.get("idProperty").isJsonNull()) {
        IndexedProperty.validateJsonObject(jsonObj.getAsJsonObject("idProperty"));
      }
      // validate the optional field `indexA`
      if (jsonObj.get("indexA") != null && !jsonObj.get("indexA").isJsonNull()) {
        IndexedProperty.validateJsonObject(jsonObj.getAsJsonObject("indexA"));
      }
      // validate the optional field `indexB`
      if (jsonObj.get("indexB") != null && !jsonObj.get("indexB").isJsonNull()) {
        IndexedProperty.validateJsonObject(jsonObj.getAsJsonObject("indexB"));
      }
      // validate the optional field `indexC`
      if (jsonObj.get("indexC") != null && !jsonObj.get("indexC").isJsonNull()) {
        IndexedProperty.validateJsonObject(jsonObj.getAsJsonObject("indexC"));
      }
      // validate the optional field `indexD`
      if (jsonObj.get("indexD") != null && !jsonObj.get("indexD").isJsonNull()) {
        IndexedProperty.validateJsonObject(jsonObj.getAsJsonObject("indexD"));
      }
      if (jsonObj.get("views") != null && !jsonObj.get("views").isJsonNull()) {
        JsonArray jsonArrayviews = jsonObj.getAsJsonArray("views");
        if (jsonArrayviews != null) {
          // ensure the json data is an array
          if (!jsonObj.get("views").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `views` to be an array in the JSON string but got `%s`", jsonObj.get("views").toString()));
          }

          // validate the optional field `views` (array)
          for (int i = 0; i < jsonArrayviews.size(); i++) {
            ListView.validateJsonObject(jsonArrayviews.get(i).getAsJsonObject());
          };
        }
      }
      // ensure the json data is an array
      if (!jsonObj.get("usages").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `usages` to be an array in the JSON string but got `%s`", jsonObj.get("usages").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!EntityList.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'EntityList' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<EntityList> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(EntityList.class));

       return (TypeAdapter<T>) new TypeAdapter<EntityList>() {
           @Override
           public void write(JsonWriter out, EntityList value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public EntityList read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of EntityList given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of EntityList
  * @throws IOException if the JSON string is invalid with respect to EntityList
  */
  public static EntityList fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, EntityList.class);
  }

 /**
  * Convert an instance of EntityList to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

