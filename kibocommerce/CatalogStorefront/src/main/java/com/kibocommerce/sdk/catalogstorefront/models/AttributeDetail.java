/*
 * Kibo Catalog Runtime Services
 * OpenAPI Spec for Kibo Catalog Runtime Services
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.kibocommerce.sdk.catalogstorefront.models;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.kibocommerce.sdk.catalogstorefront.models.CatalogAdminsAttributeValidation;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import org.openapitools.jackson.nullable.JsonNullable;
import java.io.Serializable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.kibocommerce.sdk.common.JSON;

/**
 * Product Attribute properties common between a Product Propery, Option, and Extra
 */
@ApiModel(description = "Product Attribute properties common between a Product Propery, Option, and Extra")
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class AttributeDetail implements Serializable {
  private static final long serialVersionUID = 1L;

  public static final String SERIALIZED_NAME_VALUE_TYPE = "valueType";
  @SerializedName(SERIALIZED_NAME_VALUE_TYPE)
  private String valueType;

  public static final String SERIALIZED_NAME_INPUT_TYPE = "inputType";
  @SerializedName(SERIALIZED_NAME_INPUT_TYPE)
  private String inputType;

  public static final String SERIALIZED_NAME_DATA_TYPE = "dataType";
  @SerializedName(SERIALIZED_NAME_DATA_TYPE)
  private String dataType;

  public static final String SERIALIZED_NAME_USAGE_TYPE = "usageType";
  @SerializedName(SERIALIZED_NAME_USAGE_TYPE)
  private String usageType;

  public static final String SERIALIZED_NAME_DATA_TYPE_SEQUENCE = "dataTypeSequence";
  @SerializedName(SERIALIZED_NAME_DATA_TYPE_SEQUENCE)
  private Integer dataTypeSequence;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_DESCRIPTION = "description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  private String description;

  public static final String SERIALIZED_NAME_VALIDATION = "validation";
  @SerializedName(SERIALIZED_NAME_VALIDATION)
  private CatalogAdminsAttributeValidation validation;

  public static final String SERIALIZED_NAME_SEARCHABLE_IN_STOREFRONT = "searchableInStorefront";
  @SerializedName(SERIALIZED_NAME_SEARCHABLE_IN_STOREFRONT)
  private Boolean searchableInStorefront;

  public static final String SERIALIZED_NAME_SEARCH_DISPLAY_VALUE = "searchDisplayValue";
  @SerializedName(SERIALIZED_NAME_SEARCH_DISPLAY_VALUE)
  private Boolean searchDisplayValue;

  public static final String SERIALIZED_NAME_ALLOW_FILTERING_AND_SORTING_IN_STOREFRONT = "allowFilteringAndSortingInStorefront";
  @SerializedName(SERIALIZED_NAME_ALLOW_FILTERING_AND_SORTING_IN_STOREFRONT)
  private Boolean allowFilteringAndSortingInStorefront;

  public static final String SERIALIZED_NAME_INDEX_VALUE_WITH_CASE = "indexValueWithCase";
  @SerializedName(SERIALIZED_NAME_INDEX_VALUE_WITH_CASE)
  private Boolean indexValueWithCase;

  public static final String SERIALIZED_NAME_CUSTOM_WEIGHT_IN_STOREFRONT_SEARCH = "customWeightInStorefrontSearch";
  @SerializedName(SERIALIZED_NAME_CUSTOM_WEIGHT_IN_STOREFRONT_SEARCH)
  private Boolean customWeightInStorefrontSearch;

  public static final String SERIALIZED_NAME_DISPLAY_INTENTION = "displayIntention";
  @SerializedName(SERIALIZED_NAME_DISPLAY_INTENTION)
  private String displayIntention;

  public static final String SERIALIZED_NAME_AVAILABLE_FOR_ORDER_ROUTING = "availableForOrderRouting";
  @SerializedName(SERIALIZED_NAME_AVAILABLE_FOR_ORDER_ROUTING)
  private Boolean availableForOrderRouting;

  public AttributeDetail() {
  }

  public AttributeDetail valueType(String valueType) {
    
    this.valueType = valueType;
    return this;
  }

   /**
   * The ValueType of the attribute. Valid values for ValueType are defined in ValueTypeTypeConst.
   * @return valueType
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The ValueType of the attribute. Valid values for ValueType are defined in ValueTypeTypeConst.")

  public String getValueType() {
    return valueType;
  }


  public void setValueType(String valueType) {
    this.valueType = valueType;
  }


  public AttributeDetail inputType(String inputType) {
    
    this.inputType = inputType;
    return this;
  }

   /**
   * The InputType type of the attribute. Valid values for InputType are defined in InputTypeConst.
   * @return inputType
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The InputType type of the attribute. Valid values for InputType are defined in InputTypeConst.")

  public String getInputType() {
    return inputType;
  }


  public void setInputType(String inputType) {
    this.inputType = inputType;
  }


  public AttributeDetail dataType(String dataType) {
    
    this.dataType = dataType;
    return this;
  }

   /**
   * The DataType of the attribute. Valid values for DataType are defined in DataTypeTypeConst.
   * @return dataType
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The DataType of the attribute. Valid values for DataType are defined in DataTypeTypeConst.")

  public String getDataType() {
    return dataType;
  }


  public void setDataType(String dataType) {
    this.dataType = dataType;
  }


  public AttributeDetail usageType(String usageType) {
    
    this.usageType = usageType;
    return this;
  }

   /**
   * The UsageType of the attribute. Valid values for the usageType are defined in UsageTypeConst .
   * @return usageType
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The UsageType of the attribute. Valid values for the usageType are defined in UsageTypeConst .")

  public String getUsageType() {
    return usageType;
  }


  public void setUsageType(String usageType) {
    this.usageType = usageType;
  }


  public AttributeDetail dataTypeSequence(Integer dataTypeSequence) {
    
    this.dataTypeSequence = dataTypeSequence;
    return this;
  }

   /**
   * A unique sequence of the attribute By dataType (used for common naming of fields in search index)
   * @return dataTypeSequence
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "A unique sequence of the attribute By dataType (used for common naming of fields in search index)")

  public Integer getDataTypeSequence() {
    return dataTypeSequence;
  }


  public void setDataTypeSequence(Integer dataTypeSequence) {
    this.dataTypeSequence = dataTypeSequence;
  }


  public AttributeDetail name(String name) {
    
    this.name = name;
    return this;
  }

   /**
   * Name of the attribute in the language specified by LocaleCode.
   * @return name
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Name of the attribute in the language specified by LocaleCode.")

  public String getName() {
    return name;
  }


  public void setName(String name) {
    this.name = name;
  }


  public AttributeDetail description(String description) {
    
    this.description = description;
    return this;
  }

   /**
   * Description of the attribute in the language specified by LocaleCode.
   * @return description
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Description of the attribute in the language specified by LocaleCode.")

  public String getDescription() {
    return description;
  }


  public void setDescription(String description) {
    this.description = description;
  }


  public AttributeDetail validation(CatalogAdminsAttributeValidation validation) {
    
    this.validation = validation;
    return this;
  }

   /**
   * Get validation
   * @return validation
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public CatalogAdminsAttributeValidation getValidation() {
    return validation;
  }


  public void setValidation(CatalogAdminsAttributeValidation validation) {
    this.validation = validation;
  }


  public AttributeDetail searchableInStorefront(Boolean searchableInStorefront) {
    
    this.searchableInStorefront = searchableInStorefront;
    return this;
  }

   /**
   * Indicates whether the attribute value is searchable.
   * @return searchableInStorefront
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Indicates whether the attribute value is searchable.")

  public Boolean getSearchableInStorefront() {
    return searchableInStorefront;
  }


  public void setSearchableInStorefront(Boolean searchableInStorefront) {
    this.searchableInStorefront = searchableInStorefront;
  }


  public AttributeDetail searchDisplayValue(Boolean searchDisplayValue) {
    
    this.searchDisplayValue = searchDisplayValue;
    return this;
  }

   /**
   * If true, the system will index the display value of string attributes instead of the canonical value for searching.   The canonical value will always be used for filtering. Does not apply for for non-string attributes.
   * @return searchDisplayValue
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "If true, the system will index the display value of string attributes instead of the canonical value for searching.   The canonical value will always be used for filtering. Does not apply for for non-string attributes.")

  public Boolean getSearchDisplayValue() {
    return searchDisplayValue;
  }


  public void setSearchDisplayValue(Boolean searchDisplayValue) {
    this.searchDisplayValue = searchDisplayValue;
  }


  public AttributeDetail allowFilteringAndSortingInStorefront(Boolean allowFilteringAndSortingInStorefront) {
    
    this.allowFilteringAndSortingInStorefront = allowFilteringAndSortingInStorefront;
    return this;
  }

   /**
   * Indicates whether the attribute should be able to be used in filters, facets, and sorting on the public storefront.
   * @return allowFilteringAndSortingInStorefront
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Indicates whether the attribute should be able to be used in filters, facets, and sorting on the public storefront.")

  public Boolean getAllowFilteringAndSortingInStorefront() {
    return allowFilteringAndSortingInStorefront;
  }


  public void setAllowFilteringAndSortingInStorefront(Boolean allowFilteringAndSortingInStorefront) {
    this.allowFilteringAndSortingInStorefront = allowFilteringAndSortingInStorefront;
  }


  public AttributeDetail indexValueWithCase(Boolean indexValueWithCase) {
    
    this.indexValueWithCase = indexValueWithCase;
    return this;
  }

   /**
   * Indicates whether the attribtue value is indexed with case or not
   * @return indexValueWithCase
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Indicates whether the attribtue value is indexed with case or not")

  public Boolean getIndexValueWithCase() {
    return indexValueWithCase;
  }


  public void setIndexValueWithCase(Boolean indexValueWithCase) {
    this.indexValueWithCase = indexValueWithCase;
  }


  public AttributeDetail customWeightInStorefrontSearch(Boolean customWeightInStorefrontSearch) {
    
    this.customWeightInStorefrontSearch = customWeightInStorefrontSearch;
    return this;
  }

   /**
   * Indicates whether the attribtue value is indexed so that it can have a custom relevency weight compared to other attributes in a tokenized text search
   * @return customWeightInStorefrontSearch
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Indicates whether the attribtue value is indexed so that it can have a custom relevency weight compared to other attributes in a tokenized text search")

  public Boolean getCustomWeightInStorefrontSearch() {
    return customWeightInStorefrontSearch;
  }


  public void setCustomWeightInStorefrontSearch(Boolean customWeightInStorefrontSearch) {
    this.customWeightInStorefrontSearch = customWeightInStorefrontSearch;
  }


  public AttributeDetail displayIntention(String displayIntention) {
    
    this.displayIntention = displayIntention;
    return this;
  }

   /**
   * Am optional hint to the theme about how this attribute should be displayed (what control to use)
   * @return displayIntention
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Am optional hint to the theme about how this attribute should be displayed (what control to use)")

  public String getDisplayIntention() {
    return displayIntention;
  }


  public void setDisplayIntention(String displayIntention) {
    this.displayIntention = displayIntention;
  }


  public AttributeDetail availableForOrderRouting(Boolean availableForOrderRouting) {
    
    this.availableForOrderRouting = availableForOrderRouting;
    return this;
  }

   /**
   * Indicates whether the attribute is available for order routing
   * @return availableForOrderRouting
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Indicates whether the attribute is available for order routing")

  public Boolean getAvailableForOrderRouting() {
    return availableForOrderRouting;
  }


  public void setAvailableForOrderRouting(Boolean availableForOrderRouting) {
    this.availableForOrderRouting = availableForOrderRouting;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    AttributeDetail attributeDetail = (AttributeDetail) o;
    return Objects.equals(this.valueType, attributeDetail.valueType) &&
        Objects.equals(this.inputType, attributeDetail.inputType) &&
        Objects.equals(this.dataType, attributeDetail.dataType) &&
        Objects.equals(this.usageType, attributeDetail.usageType) &&
        Objects.equals(this.dataTypeSequence, attributeDetail.dataTypeSequence) &&
        Objects.equals(this.name, attributeDetail.name) &&
        Objects.equals(this.description, attributeDetail.description) &&
        Objects.equals(this.validation, attributeDetail.validation) &&
        Objects.equals(this.searchableInStorefront, attributeDetail.searchableInStorefront) &&
        Objects.equals(this.searchDisplayValue, attributeDetail.searchDisplayValue) &&
        Objects.equals(this.allowFilteringAndSortingInStorefront, attributeDetail.allowFilteringAndSortingInStorefront) &&
        Objects.equals(this.indexValueWithCase, attributeDetail.indexValueWithCase) &&
        Objects.equals(this.customWeightInStorefrontSearch, attributeDetail.customWeightInStorefrontSearch) &&
        Objects.equals(this.displayIntention, attributeDetail.displayIntention) &&
        Objects.equals(this.availableForOrderRouting, attributeDetail.availableForOrderRouting);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(valueType, inputType, dataType, usageType, dataTypeSequence, name, description, validation, searchableInStorefront, searchDisplayValue, allowFilteringAndSortingInStorefront, indexValueWithCase, customWeightInStorefrontSearch, displayIntention, availableForOrderRouting);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class AttributeDetail {\n");
    sb.append("    valueType: ").append(toIndentedString(valueType)).append("\n");
    sb.append("    inputType: ").append(toIndentedString(inputType)).append("\n");
    sb.append("    dataType: ").append(toIndentedString(dataType)).append("\n");
    sb.append("    usageType: ").append(toIndentedString(usageType)).append("\n");
    sb.append("    dataTypeSequence: ").append(toIndentedString(dataTypeSequence)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    validation: ").append(toIndentedString(validation)).append("\n");
    sb.append("    searchableInStorefront: ").append(toIndentedString(searchableInStorefront)).append("\n");
    sb.append("    searchDisplayValue: ").append(toIndentedString(searchDisplayValue)).append("\n");
    sb.append("    allowFilteringAndSortingInStorefront: ").append(toIndentedString(allowFilteringAndSortingInStorefront)).append("\n");
    sb.append("    indexValueWithCase: ").append(toIndentedString(indexValueWithCase)).append("\n");
    sb.append("    customWeightInStorefrontSearch: ").append(toIndentedString(customWeightInStorefrontSearch)).append("\n");
    sb.append("    displayIntention: ").append(toIndentedString(displayIntention)).append("\n");
    sb.append("    availableForOrderRouting: ").append(toIndentedString(availableForOrderRouting)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("valueType");
    openapiFields.add("inputType");
    openapiFields.add("dataType");
    openapiFields.add("usageType");
    openapiFields.add("dataTypeSequence");
    openapiFields.add("name");
    openapiFields.add("description");
    openapiFields.add("validation");
    openapiFields.add("searchableInStorefront");
    openapiFields.add("searchDisplayValue");
    openapiFields.add("allowFilteringAndSortingInStorefront");
    openapiFields.add("indexValueWithCase");
    openapiFields.add("customWeightInStorefrontSearch");
    openapiFields.add("displayIntention");
    openapiFields.add("availableForOrderRouting");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to AttributeDetail
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!AttributeDetail.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in AttributeDetail is not found in the empty JSON string", AttributeDetail.openapiRequiredFields.toString()));
        }
      }

      // Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      // for (Entry<String, JsonElement> entry : entries) {
      //  if (!AttributeDetail.openapiFields.contains(entry.getKey())) {
      //    throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `AttributeDetail` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
      //    }
      //  }
      
      if ((jsonObj.get("valueType") != null && !jsonObj.get("valueType").isJsonNull()) && !jsonObj.get("valueType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `valueType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("valueType").toString()));
      }
      if ((jsonObj.get("inputType") != null && !jsonObj.get("inputType").isJsonNull()) && !jsonObj.get("inputType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `inputType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("inputType").toString()));
      }
      if ((jsonObj.get("dataType") != null && !jsonObj.get("dataType").isJsonNull()) && !jsonObj.get("dataType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `dataType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("dataType").toString()));
      }
      if ((jsonObj.get("usageType") != null && !jsonObj.get("usageType").isJsonNull()) && !jsonObj.get("usageType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `usageType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("usageType").toString()));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if ((jsonObj.get("description") != null && !jsonObj.get("description").isJsonNull()) && !jsonObj.get("description").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `description` to be a primitive type in the JSON string but got `%s`", jsonObj.get("description").toString()));
      }
      // validate the optional field `validation`
      if (jsonObj.get("validation") != null && !jsonObj.get("validation").isJsonNull()) {
        CatalogAdminsAttributeValidation.validateJsonObject(jsonObj.getAsJsonObject("validation"));
      }
      if ((jsonObj.get("displayIntention") != null && !jsonObj.get("displayIntention").isJsonNull()) && !jsonObj.get("displayIntention").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `displayIntention` to be a primitive type in the JSON string but got `%s`", jsonObj.get("displayIntention").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!AttributeDetail.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'AttributeDetail' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<AttributeDetail> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(AttributeDetail.class));

       return (TypeAdapter<T>) new TypeAdapter<AttributeDetail>() {
           @Override
           public void write(JsonWriter out, AttributeDetail value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public AttributeDetail read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of AttributeDetail given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of AttributeDetail
  * @throws IOException if the JSON string is invalid with respect to AttributeDetail
  */
  public static AttributeDetail fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, AttributeDetail.class);
  }

 /**
  * Convert an instance of AttributeDetail to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

