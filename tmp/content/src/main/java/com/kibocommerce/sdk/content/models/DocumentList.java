/*
 * Kibo Content Service
 * OpenAPI Spec for Kibo Content Service
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.kibocommerce.sdk.content.models;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.kibocommerce.sdk.content.models.View;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import org.openapitools.jackson.nullable.JsonNullable;
import java.io.Serializable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.kibocommerce.sdk.common.JSON;

/**
 * A container for documents and related settings, such as supported documentTypes and publishing.   A documentList belongs to a Mozu context, denoted by the documentList scopyeType and scopeId fields.   Example: documentList A belongs to catalog 123, denoted by the documentList scopeType value of catalog and scopeId value of 123.  A documentList can only be accessed if the API context is inclusive of the documentList&#39;s scope.  Example: documentList A belongs to catalog 123. An API call with an API context of catalog 123 will be able to address documentList A.  Example: site 456 uses catalog 123. An API call with an API context of site 456 will be able to address documentList A.  Example: masterCatalog 789 is the parent of catalog 123. An API call with an API context of masterCatalog 789 will NOT be able to address documentList A.  Documents can be created, queried, managed and published from within a documentList. A documentList may be directly created, or indirectly created from a documentListType.
 */
@ApiModel(description = "A container for documents and related settings, such as supported documentTypes and publishing.   A documentList belongs to a Mozu context, denoted by the documentList scopyeType and scopeId fields.   Example: documentList A belongs to catalog 123, denoted by the documentList scopeType value of catalog and scopeId value of 123.  A documentList can only be accessed if the API context is inclusive of the documentList's scope.  Example: documentList A belongs to catalog 123. An API call with an API context of catalog 123 will be able to address documentList A.  Example: site 456 uses catalog 123. An API call with an API context of site 456 will be able to address documentList A.  Example: masterCatalog 789 is the parent of catalog 123. An API call with an API context of masterCatalog 789 will NOT be able to address documentList A.  Documents can be created, queried, managed and published from within a documentList. A documentList may be directly created, or indirectly created from a documentListType.")
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class DocumentList implements Serializable {
  private static final long serialVersionUID = 1L;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_NAMESPACE = "namespace";
  @SerializedName(SERIALIZED_NAME_NAMESPACE)
  private String namespace;

  public static final String SERIALIZED_NAME_LIST_F_Q_N = "listFQN";
  @SerializedName(SERIALIZED_NAME_LIST_F_Q_N)
  private String listFQN;

  public static final String SERIALIZED_NAME_DOCUMENT_TYPES = "documentTypes";
  @SerializedName(SERIALIZED_NAME_DOCUMENT_TYPES)
  private List<String> documentTypes = null;

  public static final String SERIALIZED_NAME_SUPPORTS_PUBLISHING = "supportsPublishing";
  @SerializedName(SERIALIZED_NAME_SUPPORTS_PUBLISHING)
  private Boolean supportsPublishing;

  public static final String SERIALIZED_NAME_ENABLE_PUBLISHING = "enablePublishing";
  @SerializedName(SERIALIZED_NAME_ENABLE_PUBLISHING)
  private Boolean enablePublishing;

  public static final String SERIALIZED_NAME_SUPPORTS_ACTIVE_DATE_RANGES = "supportsActiveDateRanges";
  @SerializedName(SERIALIZED_NAME_SUPPORTS_ACTIVE_DATE_RANGES)
  private Boolean supportsActiveDateRanges;

  public static final String SERIALIZED_NAME_ENABLE_ACTIVE_DATE_RANGES = "enableActiveDateRanges";
  @SerializedName(SERIALIZED_NAME_ENABLE_ACTIVE_DATE_RANGES)
  private Boolean enableActiveDateRanges;

  public static final String SERIALIZED_NAME_VIEWS = "views";
  @SerializedName(SERIALIZED_NAME_VIEWS)
  private List<View> views = null;

  public static final String SERIALIZED_NAME_USAGES = "usages";
  @SerializedName(SERIALIZED_NAME_USAGES)
  private List<String> usages = null;

  public static final String SERIALIZED_NAME_SECURITY = "security";
  @SerializedName(SERIALIZED_NAME_SECURITY)
  private String security;

  public static final String SERIALIZED_NAME_SCOPE_ID = "scopeId";
  @SerializedName(SERIALIZED_NAME_SCOPE_ID)
  private Integer scopeId;

  public static final String SERIALIZED_NAME_SCOPE_TYPE = "scopeType";
  @SerializedName(SERIALIZED_NAME_SCOPE_TYPE)
  private String scopeType;

  public static final String SERIALIZED_NAME_DOCUMENT_LIST_TYPE = "documentListType";
  @SerializedName(SERIALIZED_NAME_DOCUMENT_LIST_TYPE)
  private String documentListType;

  public static final String SERIALIZED_NAME_METADATA = "metadata";
  @SerializedName(SERIALIZED_NAME_METADATA)
  private Object metadata = null;

  public DocumentList() {
  }

  public DocumentList name(String name) {
    
    this.name = name;
    return this;
  }

   /**
   * The name component of the listFQN, name@namespace. The name must be unique within the namespace component and cannot be updated.  If the documentList is based on a documentListType, then this value will be derived from the documentListType.
   * @return name
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The name component of the listFQN, name@namespace. The name must be unique within the namespace component and cannot be updated.  If the documentList is based on a documentListType, then this value will be derived from the documentListType.")

  public String getName() {
    return name;
  }


  public void setName(String name) {
    this.name = name;
  }


  public DocumentList namespace(String namespace) {
    
    this.namespace = namespace;
    return this;
  }

   /**
   * The namespace component of the listFQN, name@namespace. The issued dev account namespace must be used unless elevated privileges allow a blank namespace to be used. The namespace cannot be updated.  If the documentList is based on a documentListType, then this value will be derived from the documentListType.
   * @return namespace
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The namespace component of the listFQN, name@namespace. The issued dev account namespace must be used unless elevated privileges allow a blank namespace to be used. The namespace cannot be updated.  If the documentList is based on a documentListType, then this value will be derived from the documentListType.")

  public String getNamespace() {
    return namespace;
  }


  public void setNamespace(String namespace) {
    this.namespace = namespace;
  }


  public DocumentList listFQN(String listFQN) {
    
    this.listFQN = listFQN;
    return this;
  }

   /**
   * The unique identifier of the documentList, represented by name@namespace. The listFQN must be provided when creating the documentList, or the name and namespace fields must be provided.  If the documentList is based on a documentListType, then this value will be derived from the documentListType.
   * @return listFQN
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The unique identifier of the documentList, represented by name@namespace. The listFQN must be provided when creating the documentList, or the name and namespace fields must be provided.  If the documentList is based on a documentListType, then this value will be derived from the documentListType.")

  public String getListFQN() {
    return listFQN;
  }


  public void setListFQN(String listFQN) {
    this.listFQN = listFQN;
  }


  public DocumentList documentTypes(List<String> documentTypes) {
    
    this.documentTypes = documentTypes;
    return this;
  }

  public DocumentList addDocumentTypesItem(String documentTypesItem) {
    if (this.documentTypes == null) {
      this.documentTypes = new ArrayList<>();
    }
    this.documentTypes.add(documentTypesItem);
    return this;
  }

   /**
   * An array of the full names (name@namespace) of the documentTypes supported by the documentList. A document in the documentList must belong to one of these documentTypes.  If the documentList is based on a documentListType, then this value will be derived from the documentListType. DocumentTypes can be added/removed to the documentList, even when  based on a documentListType. Existing documents that belong to a documentType removed from the documentList will not be removed.
   * @return documentTypes
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "An array of the full names (name@namespace) of the documentTypes supported by the documentList. A document in the documentList must belong to one of these documentTypes.  If the documentList is based on a documentListType, then this value will be derived from the documentListType. DocumentTypes can be added/removed to the documentList, even when  based on a documentListType. Existing documents that belong to a documentType removed from the documentList will not be removed.")

  public List<String> getDocumentTypes() {
    return documentTypes;
  }


  public void setDocumentTypes(List<String> documentTypes) {
    this.documentTypes = documentTypes;
  }


  public DocumentList supportsPublishing(Boolean supportsPublishing) {
    
    this.supportsPublishing = supportsPublishing;
    return this;
  }

   /**
   * Determines if the documentList will support drafting and publishing documents.   This field defaults to false and cannot be updated.  If the documentList is based on a documentListType, then this value will be derived from the documentListType.
   * @return supportsPublishing
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Determines if the documentList will support drafting and publishing documents.   This field defaults to false and cannot be updated.  If the documentList is based on a documentListType, then this value will be derived from the documentListType.")

  public Boolean getSupportsPublishing() {
    return supportsPublishing;
  }


  public void setSupportsPublishing(Boolean supportsPublishing) {
    this.supportsPublishing = supportsPublishing;
  }


  public DocumentList enablePublishing(Boolean enablePublishing) {
    
    this.enablePublishing = enablePublishing;
    return this;
  }

   /**
   * Determines if the documentList has publishing turned on or off. If the documentList has a supportsPublishing value of true, then the enablePublishing value will be honored.  If enablePublishing is true, then a document draft will be created for a document create or update operation. A document must then be published to become \&quot;active\&quot;.  If enablePublish is false, then all document changes are immediately \&quot;active\&quot;.  If enablePublish is true, then updating it to false will immediately publish all draft changes.  If the documentList is based on a documentListType, then this value will be derived from the documentListType, but can be overridden on update.
   * @return enablePublishing
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Determines if the documentList has publishing turned on or off. If the documentList has a supportsPublishing value of true, then the enablePublishing value will be honored.  If enablePublishing is true, then a document draft will be created for a document create or update operation. A document must then be published to become \"active\".  If enablePublish is false, then all document changes are immediately \"active\".  If enablePublish is true, then updating it to false will immediately publish all draft changes.  If the documentList is based on a documentListType, then this value will be derived from the documentListType, but can be overridden on update.")

  public Boolean getEnablePublishing() {
    return enablePublishing;
  }


  public void setEnablePublishing(Boolean enablePublishing) {
    this.enablePublishing = enablePublishing;
  }


  public DocumentList supportsActiveDateRanges(Boolean supportsActiveDateRanges) {
    
    this.supportsActiveDateRanges = supportsActiveDateRanges;
    return this;
  }

   /**
   * Determines if the documentList will support ranges of dates that documents are considered &#39;active&#39;.   This field defaults to false and cannot be updated.  If the documentList is based on a documentListType, then this value will be derived from the documentListType.
   * @return supportsActiveDateRanges
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Determines if the documentList will support ranges of dates that documents are considered 'active'.   This field defaults to false and cannot be updated.  If the documentList is based on a documentListType, then this value will be derived from the documentListType.")

  public Boolean getSupportsActiveDateRanges() {
    return supportsActiveDateRanges;
  }


  public void setSupportsActiveDateRanges(Boolean supportsActiveDateRanges) {
    this.supportsActiveDateRanges = supportsActiveDateRanges;
  }


  public DocumentList enableActiveDateRanges(Boolean enableActiveDateRanges) {
    
    this.enableActiveDateRanges = enableActiveDateRanges;
    return this;
  }

   /**
   * Determines if the documentList has ActiveDateRanges turned on or off. If the documentList has a supportsActiveDateRanges value of true, then the enableActiveDateRanges value will be honored.  If enableActiveDateRanges is true, then a document will only be returned if the request is made within the time frame the document has been set to be &#39;active&#39;.  If enableActiveDateRanges is false, then the properties can be set but will not be honored.  If enableActiveDateRanges is true, then updating it to false will immediately start honoring the previously-set date range.  If the documentList is based on a documentListType, then this value will be derived from the documentListType, but can be overridden on update.
   * @return enableActiveDateRanges
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Determines if the documentList has ActiveDateRanges turned on or off. If the documentList has a supportsActiveDateRanges value of true, then the enableActiveDateRanges value will be honored.  If enableActiveDateRanges is true, then a document will only be returned if the request is made within the time frame the document has been set to be 'active'.  If enableActiveDateRanges is false, then the properties can be set but will not be honored.  If enableActiveDateRanges is true, then updating it to false will immediately start honoring the previously-set date range.  If the documentList is based on a documentListType, then this value will be derived from the documentListType, but can be overridden on update.")

  public Boolean getEnableActiveDateRanges() {
    return enableActiveDateRanges;
  }


  public void setEnableActiveDateRanges(Boolean enableActiveDateRanges) {
    this.enableActiveDateRanges = enableActiveDateRanges;
  }


  public DocumentList views(List<View> views) {
    
    this.views = views;
    return this;
  }

  public DocumentList addViewsItem(View viewsItem) {
    if (this.views == null) {
      this.views = new ArrayList<>();
    }
    this.views.add(viewsItem);
    return this;
  }

   /**
   * An array of one or more views, which each allow GET access to a projection of fields from the documents in the given documentList.   If the documentList is based on a documentListType, then this value will be derived from the documentListType. Views can be added/removed to the documentList, even when  the documentList derives from a documentListType.
   * @return views
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "An array of one or more views, which each allow GET access to a projection of fields from the documents in the given documentList.   If the documentList is based on a documentListType, then this value will be derived from the documentListType. Views can be added/removed to the documentList, even when  the documentList derives from a documentListType.")

  public List<View> getViews() {
    return views;
  }


  public void setViews(List<View> views) {
    this.views = views;
  }


  public DocumentList usages(List<String> usages) {
    
    this.usages = usages;
    return this;
  }

  public DocumentList addUsagesItem(String usagesItem) {
    if (this.usages == null) {
      this.usages = new ArrayList<>();
    }
    this.usages.add(usagesItem);
    return this;
  }

   /**
   * An array of strings that describes to the Mozu platform the manner(s) in which a documentList can be used. The following values are valid:  entitymanager -- the documentList should be visible in the Admin Content/Entities UI, which allows admin users to create, manage and publish documents within the documentList.  sitebuilder -- the documentList should be visible in Site Builder. A documentList will display in the Site Builder Navigation Content List node, which supports document creation, management and web cms integration.  If the documentList is based on a documentListType, then this value will be derived from the documentListType. Usages can be added or removed from the documentList, even when the documentList derives from a  documentListType.
   * @return usages
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "An array of strings that describes to the Mozu platform the manner(s) in which a documentList can be used. The following values are valid:  entitymanager -- the documentList should be visible in the Admin Content/Entities UI, which allows admin users to create, manage and publish documents within the documentList.  sitebuilder -- the documentList should be visible in Site Builder. A documentList will display in the Site Builder Navigation Content List node, which supports document creation, management and web cms integration.  If the documentList is based on a documentListType, then this value will be derived from the documentListType. Usages can be added or removed from the documentList, even when the documentList derives from a  documentListType.")

  public List<String> getUsages() {
    return usages;
  }


  public void setUsages(List<String> usages) {
    this.usages = usages;
  }


  public DocumentList security(String security) {
    
    this.security = security;
    return this;
  }

   /**
   * tbd
   * @return security
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "tbd")

  public String getSecurity() {
    return security;
  }


  public void setSecurity(String security) {
    this.security = security;
  }


  public DocumentList scopeId(Integer scopeId) {
    
    this.scopeId = scopeId;
    return this;
  }

   /**
   * Used in conjunction with the scopeType field to determine the exact context within which the documentList resides.  Example: A documentList with a scopeId of 5 and scopeType of masterCatalog belongs to masterCatalog 5.  If the documentList is based on a documentListType, then this value will be derived from the documentListType. This value is read-only after the documentList is created.
   * @return scopeId
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Used in conjunction with the scopeType field to determine the exact context within which the documentList resides.  Example: A documentList with a scopeId of 5 and scopeType of masterCatalog belongs to masterCatalog 5.  If the documentList is based on a documentListType, then this value will be derived from the documentListType. This value is read-only after the documentList is created.")

  public Integer getScopeId() {
    return scopeId;
  }


  public void setScopeId(Integer scopeId) {
    this.scopeId = scopeId;
  }


  public DocumentList scopeType(String scopeType) {
    
    this.scopeType = scopeType;
    return this;
  }

   /**
   * The context level the documentList resides in. Valid values are \&quot;tenant\&quot;, \&quot;masterCatalog\&quot;, \&quot;catalog\&quot; and \&quot;site\&quot;. This field is used in conjunction with the scopeId field  to determine the exact context within which this documentList resides. This field is read-only after insert.  If the documentList is based on a documentListType, then this value will be derived from the documentListType. This value is read-only after the documentList is created.
   * @return scopeType
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The context level the documentList resides in. Valid values are \"tenant\", \"masterCatalog\", \"catalog\" and \"site\". This field is used in conjunction with the scopeId field  to determine the exact context within which this documentList resides. This field is read-only after insert.  If the documentList is based on a documentListType, then this value will be derived from the documentListType. This value is read-only after the documentList is created.")

  public String getScopeType() {
    return scopeType;
  }


  public void setScopeType(String scopeType) {
    this.scopeType = scopeType;
  }


  public DocumentList documentListType(String documentListType) {
    
    this.documentListType = documentListType;
    return this;
  }

   /**
   * The full name of the documentListType (name@namespace) that underlies the documentList. This value is only populated when the Mozu platform creates a documentList from a documentListType.  A documentList that is directly created cannot specify a documentListType. This field is therefore read-only.
   * @return documentListType
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The full name of the documentListType (name@namespace) that underlies the documentList. This value is only populated when the Mozu platform creates a documentList from a documentListType.  A documentList that is directly created cannot specify a documentListType. This field is therefore read-only.")

  public String getDocumentListType() {
    return documentListType;
  }


  public void setDocumentListType(String documentListType) {
    this.documentListType = documentListType;
  }


  public DocumentList metadata(Object metadata) {
    
    this.metadata = metadata;
    return this;
  }

   /**
   * Allows arbitrary data to be stored on the documentList.  If the documentList is based on a documentListType, then this value will be derived from the documentListType, but can be overridden on update.
   * @return metadata
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Allows arbitrary data to be stored on the documentList.  If the documentList is based on a documentListType, then this value will be derived from the documentListType, but can be overridden on update.")

  public Object getMetadata() {
    return metadata;
  }


  public void setMetadata(Object metadata) {
    this.metadata = metadata;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DocumentList documentList = (DocumentList) o;
    return Objects.equals(this.name, documentList.name) &&
        Objects.equals(this.namespace, documentList.namespace) &&
        Objects.equals(this.listFQN, documentList.listFQN) &&
        Objects.equals(this.documentTypes, documentList.documentTypes) &&
        Objects.equals(this.supportsPublishing, documentList.supportsPublishing) &&
        Objects.equals(this.enablePublishing, documentList.enablePublishing) &&
        Objects.equals(this.supportsActiveDateRanges, documentList.supportsActiveDateRanges) &&
        Objects.equals(this.enableActiveDateRanges, documentList.enableActiveDateRanges) &&
        Objects.equals(this.views, documentList.views) &&
        Objects.equals(this.usages, documentList.usages) &&
        Objects.equals(this.security, documentList.security) &&
        Objects.equals(this.scopeId, documentList.scopeId) &&
        Objects.equals(this.scopeType, documentList.scopeType) &&
        Objects.equals(this.documentListType, documentList.documentListType) &&
        Objects.equals(this.metadata, documentList.metadata);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(name, namespace, listFQN, documentTypes, supportsPublishing, enablePublishing, supportsActiveDateRanges, enableActiveDateRanges, views, usages, security, scopeId, scopeType, documentListType, metadata);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DocumentList {\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    namespace: ").append(toIndentedString(namespace)).append("\n");
    sb.append("    listFQN: ").append(toIndentedString(listFQN)).append("\n");
    sb.append("    documentTypes: ").append(toIndentedString(documentTypes)).append("\n");
    sb.append("    supportsPublishing: ").append(toIndentedString(supportsPublishing)).append("\n");
    sb.append("    enablePublishing: ").append(toIndentedString(enablePublishing)).append("\n");
    sb.append("    supportsActiveDateRanges: ").append(toIndentedString(supportsActiveDateRanges)).append("\n");
    sb.append("    enableActiveDateRanges: ").append(toIndentedString(enableActiveDateRanges)).append("\n");
    sb.append("    views: ").append(toIndentedString(views)).append("\n");
    sb.append("    usages: ").append(toIndentedString(usages)).append("\n");
    sb.append("    security: ").append(toIndentedString(security)).append("\n");
    sb.append("    scopeId: ").append(toIndentedString(scopeId)).append("\n");
    sb.append("    scopeType: ").append(toIndentedString(scopeType)).append("\n");
    sb.append("    documentListType: ").append(toIndentedString(documentListType)).append("\n");
    sb.append("    metadata: ").append(toIndentedString(metadata)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("name");
    openapiFields.add("namespace");
    openapiFields.add("listFQN");
    openapiFields.add("documentTypes");
    openapiFields.add("supportsPublishing");
    openapiFields.add("enablePublishing");
    openapiFields.add("supportsActiveDateRanges");
    openapiFields.add("enableActiveDateRanges");
    openapiFields.add("views");
    openapiFields.add("usages");
    openapiFields.add("security");
    openapiFields.add("scopeId");
    openapiFields.add("scopeType");
    openapiFields.add("documentListType");
    openapiFields.add("metadata");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to DocumentList
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!DocumentList.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in DocumentList is not found in the empty JSON string", DocumentList.openapiRequiredFields.toString()));
        }
      }

      // Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      // for (Entry<String, JsonElement> entry : entries) {
      //  if (!DocumentList.openapiFields.contains(entry.getKey())) {
      //    throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `DocumentList` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
      //    }
      //  }
      
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if ((jsonObj.get("namespace") != null && !jsonObj.get("namespace").isJsonNull()) && !jsonObj.get("namespace").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `namespace` to be a primitive type in the JSON string but got `%s`", jsonObj.get("namespace").toString()));
      }
      if ((jsonObj.get("listFQN") != null && !jsonObj.get("listFQN").isJsonNull()) && !jsonObj.get("listFQN").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `listFQN` to be a primitive type in the JSON string but got `%s`", jsonObj.get("listFQN").toString()));
      }
      // ensure the json data is an array
      if (!jsonObj.get("documentTypes").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `documentTypes` to be an array in the JSON string but got `%s`", jsonObj.get("documentTypes").toString()));
      }
      if (jsonObj.get("views") != null && !jsonObj.get("views").isJsonNull()) {
        JsonArray jsonArrayviews = jsonObj.getAsJsonArray("views");
        if (jsonArrayviews != null) {
          // ensure the json data is an array
          if (!jsonObj.get("views").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `views` to be an array in the JSON string but got `%s`", jsonObj.get("views").toString()));
          }

          // validate the optional field `views` (array)
          for (int i = 0; i < jsonArrayviews.size(); i++) {
            View.validateJsonObject(jsonArrayviews.get(i).getAsJsonObject());
          };
        }
      }
      // ensure the json data is an array
      if (!jsonObj.get("usages").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `usages` to be an array in the JSON string but got `%s`", jsonObj.get("usages").toString()));
      }
      if ((jsonObj.get("security") != null && !jsonObj.get("security").isJsonNull()) && !jsonObj.get("security").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `security` to be a primitive type in the JSON string but got `%s`", jsonObj.get("security").toString()));
      }
      if ((jsonObj.get("scopeType") != null && !jsonObj.get("scopeType").isJsonNull()) && !jsonObj.get("scopeType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `scopeType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("scopeType").toString()));
      }
      if ((jsonObj.get("documentListType") != null && !jsonObj.get("documentListType").isJsonNull()) && !jsonObj.get("documentListType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `documentListType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("documentListType").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!DocumentList.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'DocumentList' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<DocumentList> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(DocumentList.class));

       return (TypeAdapter<T>) new TypeAdapter<DocumentList>() {
           @Override
           public void write(JsonWriter out, DocumentList value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public DocumentList read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of DocumentList given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of DocumentList
  * @throws IOException if the JSON string is invalid with respect to DocumentList
  */
  public static DocumentList fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DocumentList.class);
  }

 /**
  * Convert an instance of DocumentList to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

