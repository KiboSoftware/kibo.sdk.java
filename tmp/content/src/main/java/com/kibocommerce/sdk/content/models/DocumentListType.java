/*
 * Kibo Content Service
 * OpenAPI Spec for Kibo Content Service
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.kibocommerce.sdk.content.models;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.kibocommerce.sdk.content.models.DocumentInstallation;
import com.kibocommerce.sdk.content.models.View;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import org.openapitools.jackson.nullable.JsonNullable;
import java.io.Serializable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.kibocommerce.sdk.common.JSON;

/**
 * A documentListType instructs the Mozu platform to automatically create documentLists within a scopeType. Example: Creating a documentListType in tenant X with a   scopeType of site tells the Mozu platform to immediately create a documentList in each site tenant X has. The Mozu platform will also automatically create a new   documentList for every site subsequently provisioned in tenant X. Any defaultDocuments defined on the documentListType will be created within   each documentList. Each documentList will be addressable via the documenetListType&#39;s fully qualified name and will, by default, use the documentListType&#39;s views,   usages and metadata. Therefore the documentListType can be used to centrally manage each associated documentList.
 */
@ApiModel(description = "A documentListType instructs the Mozu platform to automatically create documentLists within a scopeType. Example: Creating a documentListType in tenant X with a   scopeType of site tells the Mozu platform to immediately create a documentList in each site tenant X has. The Mozu platform will also automatically create a new   documentList for every site subsequently provisioned in tenant X. Any defaultDocuments defined on the documentListType will be created within   each documentList. Each documentList will be addressable via the documenetListType's fully qualified name and will, by default, use the documentListType's views,   usages and metadata. Therefore the documentListType can be used to centrally manage each associated documentList.")
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class DocumentListType implements Serializable {
  private static final long serialVersionUID = 1L;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_NAMESPACE = "namespace";
  @SerializedName(SERIALIZED_NAME_NAMESPACE)
  private String namespace;

  public static final String SERIALIZED_NAME_DOCUMENT_LIST_TYPE_F_Q_N = "documentListTypeFQN";
  @SerializedName(SERIALIZED_NAME_DOCUMENT_LIST_TYPE_F_Q_N)
  private String documentListTypeFQN;

  public static final String SERIALIZED_NAME_SCOPE_TYPE = "scopeType";
  @SerializedName(SERIALIZED_NAME_SCOPE_TYPE)
  private String scopeType;

  public static final String SERIALIZED_NAME_INSTALLATION_PACKAGE = "installationPackage";
  @SerializedName(SERIALIZED_NAME_INSTALLATION_PACKAGE)
  private String installationPackage;

  public static final String SERIALIZED_NAME_VERSION = "version";
  @SerializedName(SERIALIZED_NAME_VERSION)
  private String version;

  public static final String SERIALIZED_NAME_DEFAULT_DOCUMENTS = "defaultDocuments";
  @SerializedName(SERIALIZED_NAME_DEFAULT_DOCUMENTS)
  private List<DocumentInstallation> defaultDocuments = null;

  public static final String SERIALIZED_NAME_DOCUMENT_TYPE_F_Q_NS = "documentTypeFQNs";
  @SerializedName(SERIALIZED_NAME_DOCUMENT_TYPE_F_Q_NS)
  private List<String> documentTypeFQNs = null;

  public static final String SERIALIZED_NAME_SUPPORTS_PUBLISHING = "supportsPublishing";
  @SerializedName(SERIALIZED_NAME_SUPPORTS_PUBLISHING)
  private Boolean supportsPublishing;

  public static final String SERIALIZED_NAME_ENABLE_PUBLISHING = "enablePublishing";
  @SerializedName(SERIALIZED_NAME_ENABLE_PUBLISHING)
  private Boolean enablePublishing;

  public static final String SERIALIZED_NAME_SUPPORTS_ACTIVE_DATE_RANGES = "supportsActiveDateRanges";
  @SerializedName(SERIALIZED_NAME_SUPPORTS_ACTIVE_DATE_RANGES)
  private Boolean supportsActiveDateRanges;

  public static final String SERIALIZED_NAME_ENABLE_ACTIVE_DATE_RANGES = "enableActiveDateRanges";
  @SerializedName(SERIALIZED_NAME_ENABLE_ACTIVE_DATE_RANGES)
  private Boolean enableActiveDateRanges;

  public static final String SERIALIZED_NAME_VIEWS = "views";
  @SerializedName(SERIALIZED_NAME_VIEWS)
  private List<View> views = null;

  public static final String SERIALIZED_NAME_USAGES = "usages";
  @SerializedName(SERIALIZED_NAME_USAGES)
  private List<String> usages = null;

  public static final String SERIALIZED_NAME_METADATA = "metadata";
  @SerializedName(SERIALIZED_NAME_METADATA)
  private Object metadata = null;

  public DocumentListType() {
  }

  public DocumentListType name(String name) {
    
    this.name = name;
    return this;
  }

   /**
   * The name component of the documentListTypeFQN, name@namespace. The name must be unique within the namespace component and cannot be updated.  Each documentList created from the documentListType will use this value.
   * @return name
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The name component of the documentListTypeFQN, name@namespace. The name must be unique within the namespace component and cannot be updated.  Each documentList created from the documentListType will use this value.")

  public String getName() {
    return name;
  }


  public void setName(String name) {
    this.name = name;
  }


  public DocumentListType namespace(String namespace) {
    
    this.namespace = namespace;
    return this;
  }

   /**
   * The namespace component of the documentListTypeFQN, name@namespace. The issued dev account namespace must be used unless elevated privileges allow a blank namespace to be used. The namespace cannot be updated.  Each documentList created from the documentListType will use this value.
   * @return namespace
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The namespace component of the documentListTypeFQN, name@namespace. The issued dev account namespace must be used unless elevated privileges allow a blank namespace to be used. The namespace cannot be updated.  Each documentList created from the documentListType will use this value.")

  public String getNamespace() {
    return namespace;
  }


  public void setNamespace(String namespace) {
    this.namespace = namespace;
  }


  public DocumentListType documentListTypeFQN(String documentListTypeFQN) {
    
    this.documentListTypeFQN = documentListTypeFQN;
    return this;
  }

   /**
   * The unique identifier of the documentListType, represented by name@namespace. The documentListTypeFQN must be provided when creating the documentListType, or the name and namespace fields must be provided.  This field cannot be updated and each documentList created from the documentListType will use this value.
   * @return documentListTypeFQN
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The unique identifier of the documentListType, represented by name@namespace. The documentListTypeFQN must be provided when creating the documentListType, or the name and namespace fields must be provided.  This field cannot be updated and each documentList created from the documentListType will use this value.")

  public String getDocumentListTypeFQN() {
    return documentListTypeFQN;
  }


  public void setDocumentListTypeFQN(String documentListTypeFQN) {
    this.documentListTypeFQN = documentListTypeFQN;
  }


  public DocumentListType scopeType(String scopeType) {
    
    this.scopeType = scopeType;
    return this;
  }

   /**
   * The context level at which this documentListType will create documentLists. Valid values are \&quot;tenant\&quot;, \&quot;masterCatalog\&quot;, \&quot;catalog\&quot; and \&quot;site\&quot;. This field is read-only after insert.
   * @return scopeType
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The context level at which this documentListType will create documentLists. Valid values are \"tenant\", \"masterCatalog\", \"catalog\" and \"site\". This field is read-only after insert.")

  public String getScopeType() {
    return scopeType;
  }


  public void setScopeType(String scopeType) {
    this.scopeType = scopeType;
  }


  public DocumentListType installationPackage(String installationPackage) {
    
    this.installationPackage = installationPackage;
    return this;
  }

   /**
   * Optionally, a documentListType can be defined in an installationPackage and then installed into a tenant. Installed documentListsTypes can only be updated via installation upgrades.   Currently only internal Mozu platform components can create installations. This field is system-supplied and read-only.
   * @return installationPackage
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Optionally, a documentListType can be defined in an installationPackage and then installed into a tenant. Installed documentListsTypes can only be updated via installation upgrades.   Currently only internal Mozu platform components can create installations. This field is system-supplied and read-only.")

  public String getInstallationPackage() {
    return installationPackage;
  }


  public void setInstallationPackage(String installationPackage) {
    this.installationPackage = installationPackage;
  }


  public DocumentListType version(String version) {
    
    this.version = version;
    return this;
  }

   /**
   * The version of the installationPackge installed. This field is read-only.
   * @return version
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The version of the installationPackge installed. This field is read-only.")

  public String getVersion() {
    return version;
  }


  public void setVersion(String version) {
    this.version = version;
  }


  public DocumentListType defaultDocuments(List<DocumentInstallation> defaultDocuments) {
    
    this.defaultDocuments = defaultDocuments;
    return this;
  }

  public DocumentListType addDefaultDocumentsItem(DocumentInstallation defaultDocumentsItem) {
    if (this.defaultDocuments == null) {
      this.defaultDocuments = new ArrayList<>();
    }
    this.defaultDocuments.add(defaultDocumentsItem);
    return this;
  }

   /**
   * The definition of any documents to create when a documentList is created.
   * @return defaultDocuments
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The definition of any documents to create when a documentList is created.")

  public List<DocumentInstallation> getDefaultDocuments() {
    return defaultDocuments;
  }


  public void setDefaultDocuments(List<DocumentInstallation> defaultDocuments) {
    this.defaultDocuments = defaultDocuments;
  }


  public DocumentListType documentTypeFQNs(List<String> documentTypeFQNs) {
    
    this.documentTypeFQNs = documentTypeFQNs;
    return this;
  }

  public DocumentListType addDocumentTypeFQNsItem(String documentTypeFQNsItem) {
    if (this.documentTypeFQNs == null) {
      this.documentTypeFQNs = new ArrayList<>();
    }
    this.documentTypeFQNs.add(documentTypeFQNsItem);
    return this;
  }

   /**
   * The full names (name@namespace) of the types of documents that can be created within the documentLists belonging to this documentListType.   Each documentList created from the documentListType will use this value, but it can be overridden in an individual documentList.
   * @return documentTypeFQNs
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The full names (name@namespace) of the types of documents that can be created within the documentLists belonging to this documentListType.   Each documentList created from the documentListType will use this value, but it can be overridden in an individual documentList.")

  public List<String> getDocumentTypeFQNs() {
    return documentTypeFQNs;
  }


  public void setDocumentTypeFQNs(List<String> documentTypeFQNs) {
    this.documentTypeFQNs = documentTypeFQNs;
  }


  public DocumentListType supportsPublishing(Boolean supportsPublishing) {
    
    this.supportsPublishing = supportsPublishing;
    return this;
  }

   /**
   * Determines if documentLists belonging to this documentListType will support drafting and publishing documents.   This field defaults to false and cannot be updated. Each documentList created from the documentListType will use this value.
   * @return supportsPublishing
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Determines if documentLists belonging to this documentListType will support drafting and publishing documents.   This field defaults to false and cannot be updated. Each documentList created from the documentListType will use this value.")

  public Boolean getSupportsPublishing() {
    return supportsPublishing;
  }


  public void setSupportsPublishing(Boolean supportsPublishing) {
    this.supportsPublishing = supportsPublishing;
  }


  public DocumentListType enablePublishing(Boolean enablePublishing) {
    
    this.enablePublishing = enablePublishing;
    return this;
  }

   /**
   * Determines if documentLists belonging to this documentListType have publishing turned on or off.   Each documentList created from the documentListType will use this value, but it can be overridden in an individual documentList.
   * @return enablePublishing
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Determines if documentLists belonging to this documentListType have publishing turned on or off.   Each documentList created from the documentListType will use this value, but it can be overridden in an individual documentList.")

  public Boolean getEnablePublishing() {
    return enablePublishing;
  }


  public void setEnablePublishing(Boolean enablePublishing) {
    this.enablePublishing = enablePublishing;
  }


  public DocumentListType supportsActiveDateRanges(Boolean supportsActiveDateRanges) {
    
    this.supportsActiveDateRanges = supportsActiveDateRanges;
    return this;
  }

   /**
   * Determines if documentLists belonging to this documentListType will support drafting and ActiveDateRanges documents.   This field defaults to false and cannot be updated. Each documentList created from the documentListType will use this value.
   * @return supportsActiveDateRanges
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Determines if documentLists belonging to this documentListType will support drafting and ActiveDateRanges documents.   This field defaults to false and cannot be updated. Each documentList created from the documentListType will use this value.")

  public Boolean getSupportsActiveDateRanges() {
    return supportsActiveDateRanges;
  }


  public void setSupportsActiveDateRanges(Boolean supportsActiveDateRanges) {
    this.supportsActiveDateRanges = supportsActiveDateRanges;
  }


  public DocumentListType enableActiveDateRanges(Boolean enableActiveDateRanges) {
    
    this.enableActiveDateRanges = enableActiveDateRanges;
    return this;
  }

   /**
   * Determines if documentLists belonging to this documentListType have ActiveDateRanges turned on or off.   Each documentList created from the documentListType will use this value, but it can be overridden in an individual documentList.
   * @return enableActiveDateRanges
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Determines if documentLists belonging to this documentListType have ActiveDateRanges turned on or off.   Each documentList created from the documentListType will use this value, but it can be overridden in an individual documentList.")

  public Boolean getEnableActiveDateRanges() {
    return enableActiveDateRanges;
  }


  public void setEnableActiveDateRanges(Boolean enableActiveDateRanges) {
    this.enableActiveDateRanges = enableActiveDateRanges;
  }


  public DocumentListType views(List<View> views) {
    
    this.views = views;
    return this;
  }

  public DocumentListType addViewsItem(View viewsItem) {
    if (this.views == null) {
      this.views = new ArrayList<>();
    }
    this.views.add(viewsItem);
    return this;
  }

   /**
   * An array of one or more views, which each allow GET access to a projection of fields from the documents in the given documentList.   Each documentList created from this documentListType will use this value, but it can be overridden in an individual documentList.
   * @return views
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "An array of one or more views, which each allow GET access to a projection of fields from the documents in the given documentList.   Each documentList created from this documentListType will use this value, but it can be overridden in an individual documentList.")

  public List<View> getViews() {
    return views;
  }


  public void setViews(List<View> views) {
    this.views = views;
  }


  public DocumentListType usages(List<String> usages) {
    
    this.usages = usages;
    return this;
  }

  public DocumentListType addUsagesItem(String usagesItem) {
    if (this.usages == null) {
      this.usages = new ArrayList<>();
    }
    this.usages.add(usagesItem);
    return this;
  }

   /**
   * An array of strings that describes to the Mozu platform the manner(s) in which a documentList can be used. The following values are valid:  entitymanager -- the documentList should be visible in the Admin Content/Entities screen, which allows admin users to create, manage and publish documents within the documentList.  sitebuilder -- the documentList should be visible in Sitebuilder. A documentList will display in the Sitebuilder Navigation Content List node, which supports document creation, management and web cms integration.  Each documentList created from this documentListType will use this value, but it can be overridden in an individual documentList.
   * @return usages
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "An array of strings that describes to the Mozu platform the manner(s) in which a documentList can be used. The following values are valid:  entitymanager -- the documentList should be visible in the Admin Content/Entities screen, which allows admin users to create, manage and publish documents within the documentList.  sitebuilder -- the documentList should be visible in Sitebuilder. A documentList will display in the Sitebuilder Navigation Content List node, which supports document creation, management and web cms integration.  Each documentList created from this documentListType will use this value, but it can be overridden in an individual documentList.")

  public List<String> getUsages() {
    return usages;
  }


  public void setUsages(List<String> usages) {
    this.usages = usages;
  }


  public DocumentListType metadata(Object metadata) {
    
    this.metadata = metadata;
    return this;
  }

   /**
   * Allows arbitrary data to be stored on the documentListType. Each documentList created from this documentListType will use this value,   but it can be overridden in an individual documentList.
   * @return metadata
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Allows arbitrary data to be stored on the documentListType. Each documentList created from this documentListType will use this value,   but it can be overridden in an individual documentList.")

  public Object getMetadata() {
    return metadata;
  }


  public void setMetadata(Object metadata) {
    this.metadata = metadata;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DocumentListType documentListType = (DocumentListType) o;
    return Objects.equals(this.name, documentListType.name) &&
        Objects.equals(this.namespace, documentListType.namespace) &&
        Objects.equals(this.documentListTypeFQN, documentListType.documentListTypeFQN) &&
        Objects.equals(this.scopeType, documentListType.scopeType) &&
        Objects.equals(this.installationPackage, documentListType.installationPackage) &&
        Objects.equals(this.version, documentListType.version) &&
        Objects.equals(this.defaultDocuments, documentListType.defaultDocuments) &&
        Objects.equals(this.documentTypeFQNs, documentListType.documentTypeFQNs) &&
        Objects.equals(this.supportsPublishing, documentListType.supportsPublishing) &&
        Objects.equals(this.enablePublishing, documentListType.enablePublishing) &&
        Objects.equals(this.supportsActiveDateRanges, documentListType.supportsActiveDateRanges) &&
        Objects.equals(this.enableActiveDateRanges, documentListType.enableActiveDateRanges) &&
        Objects.equals(this.views, documentListType.views) &&
        Objects.equals(this.usages, documentListType.usages) &&
        Objects.equals(this.metadata, documentListType.metadata);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(name, namespace, documentListTypeFQN, scopeType, installationPackage, version, defaultDocuments, documentTypeFQNs, supportsPublishing, enablePublishing, supportsActiveDateRanges, enableActiveDateRanges, views, usages, metadata);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DocumentListType {\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    namespace: ").append(toIndentedString(namespace)).append("\n");
    sb.append("    documentListTypeFQN: ").append(toIndentedString(documentListTypeFQN)).append("\n");
    sb.append("    scopeType: ").append(toIndentedString(scopeType)).append("\n");
    sb.append("    installationPackage: ").append(toIndentedString(installationPackage)).append("\n");
    sb.append("    version: ").append(toIndentedString(version)).append("\n");
    sb.append("    defaultDocuments: ").append(toIndentedString(defaultDocuments)).append("\n");
    sb.append("    documentTypeFQNs: ").append(toIndentedString(documentTypeFQNs)).append("\n");
    sb.append("    supportsPublishing: ").append(toIndentedString(supportsPublishing)).append("\n");
    sb.append("    enablePublishing: ").append(toIndentedString(enablePublishing)).append("\n");
    sb.append("    supportsActiveDateRanges: ").append(toIndentedString(supportsActiveDateRanges)).append("\n");
    sb.append("    enableActiveDateRanges: ").append(toIndentedString(enableActiveDateRanges)).append("\n");
    sb.append("    views: ").append(toIndentedString(views)).append("\n");
    sb.append("    usages: ").append(toIndentedString(usages)).append("\n");
    sb.append("    metadata: ").append(toIndentedString(metadata)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("name");
    openapiFields.add("namespace");
    openapiFields.add("documentListTypeFQN");
    openapiFields.add("scopeType");
    openapiFields.add("installationPackage");
    openapiFields.add("version");
    openapiFields.add("defaultDocuments");
    openapiFields.add("documentTypeFQNs");
    openapiFields.add("supportsPublishing");
    openapiFields.add("enablePublishing");
    openapiFields.add("supportsActiveDateRanges");
    openapiFields.add("enableActiveDateRanges");
    openapiFields.add("views");
    openapiFields.add("usages");
    openapiFields.add("metadata");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to DocumentListType
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!DocumentListType.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in DocumentListType is not found in the empty JSON string", DocumentListType.openapiRequiredFields.toString()));
        }
      }

      // Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      // for (Entry<String, JsonElement> entry : entries) {
      //  if (!DocumentListType.openapiFields.contains(entry.getKey())) {
      //    throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `DocumentListType` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
      //    }
      //  }
      
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if ((jsonObj.get("namespace") != null && !jsonObj.get("namespace").isJsonNull()) && !jsonObj.get("namespace").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `namespace` to be a primitive type in the JSON string but got `%s`", jsonObj.get("namespace").toString()));
      }
      if ((jsonObj.get("documentListTypeFQN") != null && !jsonObj.get("documentListTypeFQN").isJsonNull()) && !jsonObj.get("documentListTypeFQN").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `documentListTypeFQN` to be a primitive type in the JSON string but got `%s`", jsonObj.get("documentListTypeFQN").toString()));
      }
      if ((jsonObj.get("scopeType") != null && !jsonObj.get("scopeType").isJsonNull()) && !jsonObj.get("scopeType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `scopeType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("scopeType").toString()));
      }
      if ((jsonObj.get("installationPackage") != null && !jsonObj.get("installationPackage").isJsonNull()) && !jsonObj.get("installationPackage").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `installationPackage` to be a primitive type in the JSON string but got `%s`", jsonObj.get("installationPackage").toString()));
      }
      if ((jsonObj.get("version") != null && !jsonObj.get("version").isJsonNull()) && !jsonObj.get("version").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `version` to be a primitive type in the JSON string but got `%s`", jsonObj.get("version").toString()));
      }
      if (jsonObj.get("defaultDocuments") != null && !jsonObj.get("defaultDocuments").isJsonNull()) {
        JsonArray jsonArraydefaultDocuments = jsonObj.getAsJsonArray("defaultDocuments");
        if (jsonArraydefaultDocuments != null) {
          // ensure the json data is an array
          if (!jsonObj.get("defaultDocuments").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `defaultDocuments` to be an array in the JSON string but got `%s`", jsonObj.get("defaultDocuments").toString()));
          }

          // validate the optional field `defaultDocuments` (array)
          for (int i = 0; i < jsonArraydefaultDocuments.size(); i++) {
            DocumentInstallation.validateJsonObject(jsonArraydefaultDocuments.get(i).getAsJsonObject());
          };
        }
      }
      // ensure the json data is an array
      if (!jsonObj.get("documentTypeFQNs").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `documentTypeFQNs` to be an array in the JSON string but got `%s`", jsonObj.get("documentTypeFQNs").toString()));
      }
      if (jsonObj.get("views") != null && !jsonObj.get("views").isJsonNull()) {
        JsonArray jsonArrayviews = jsonObj.getAsJsonArray("views");
        if (jsonArrayviews != null) {
          // ensure the json data is an array
          if (!jsonObj.get("views").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `views` to be an array in the JSON string but got `%s`", jsonObj.get("views").toString()));
          }

          // validate the optional field `views` (array)
          for (int i = 0; i < jsonArrayviews.size(); i++) {
            View.validateJsonObject(jsonArrayviews.get(i).getAsJsonObject());
          };
        }
      }
      // ensure the json data is an array
      if (!jsonObj.get("usages").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `usages` to be an array in the JSON string but got `%s`", jsonObj.get("usages").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!DocumentListType.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'DocumentListType' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<DocumentListType> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(DocumentListType.class));

       return (TypeAdapter<T>) new TypeAdapter<DocumentListType>() {
           @Override
           public void write(JsonWriter out, DocumentListType value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public DocumentListType read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of DocumentListType given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of DocumentListType
  * @throws IOException if the JSON string is invalid with respect to DocumentListType
  */
  public static DocumentListType fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DocumentListType.class);
  }

 /**
  * Convert an instance of DocumentListType to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

